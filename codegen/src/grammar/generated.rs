// This file was generated by Peginator v0.7.0 built at 1707642565
// CRC-32/ISO-HDLC of the grammar file: 77924b91
// Any changes to it will be lost on regeneration

#[derive(Debug, Clone)]
pub struct Grammar {
    pub rules: Vec<Grammar_rules>,
}
#[allow(non_camel_case_types)]
#[derive(Debug, Clone)]
pub enum Grammar_rules {
    CharRule(CharRule),
    ExternRule(ExternRule),
    Rule(Rule),
}
#[derive(Debug, Clone)]
pub struct Rule {
    pub directives: Vec<DirectiveExpression>,
    pub name: Identifier,
    pub definition: Choice,
}
#[derive(Debug, Clone)]
pub struct CharRule {
    pub directives: Vec<CheckDirective>,
    pub name: Identifier,
    pub choices: Vec<CharRulePart>,
}
#[allow(non_camel_case_types)]
#[derive(Debug, Clone)]
pub enum CharRulePart {
    CharRangePart(CharRangePart),
    CharacterRange(CharacterRange),
    Identifier(Identifier),
}
#[derive(Debug, Clone)]
pub struct ExternRule {
    pub directive: ExternDirective,
    pub name: Identifier,
}
#[derive(Debug, Clone)]
pub struct Choice {
    pub choices: Vec<Sequence>,
}
#[derive(Debug, Clone)]
pub struct Sequence {
    pub parts: Vec<DelimitedExpression>,
}
#[derive(Debug, Clone)]
pub struct Group {
    pub body: Choice,
}
#[derive(Debug, Clone)]
pub struct Optional {
    pub body: Choice,
}
#[derive(Debug, Clone)]
pub struct Closure {
    pub body: Choice,
    pub at_least_one: Option<AtLeastOneMarker>,
}
#[derive(Debug, Clone)]
pub struct AtLeastOneMarker;
#[derive(Debug, Clone)]
pub struct NegativeLookahead {
    pub expr: Box<DelimitedExpression>,
}
#[derive(Debug, Clone)]
pub struct PositiveLookahead {
    pub expr: Box<DelimitedExpression>,
}
#[derive(Debug, Clone)]
pub struct CharacterRange {
    pub from: CharRangePart,
    pub to: CharRangePart,
}
pub type CharRangePart = StringItem;
#[derive(Debug, Clone)]
pub struct StringLiteral {
    pub insensitive: Option<CaseInsensitiveMarker>,
    pub body: Vec<StringItem>,
}
#[derive(Debug, Clone)]
pub struct CaseInsensitiveMarker;
#[derive(Debug, Clone)]
pub struct Field {
    pub name: Option<Field_name>,
    pub boxed: Option<BoxMarker>,
    pub typ: Identifier,
}
#[allow(non_camel_case_types)]
#[derive(Debug, Clone)]
pub enum Field_name {
    Identifier(Identifier),
    OverrideMarker(OverrideMarker),
}
#[derive(Debug, Clone)]
pub struct BoxMarker;
#[derive(Debug, Clone)]
pub struct OverrideMarker;
#[derive(Debug, Clone)]
pub struct IncludeRule {
    pub rule: Identifier,
}
#[allow(non_camel_case_types)]
#[derive(Debug, Clone)]
pub enum DelimitedExpression {
    CharacterRange(CharacterRange),
    Closure(Closure),
    EndOfInput(EndOfInput),
    Field(Field),
    Group(Group),
    IncludeRule(IncludeRule),
    NegativeLookahead(NegativeLookahead),
    Optional(Optional),
    PositiveLookahead(PositiveLookahead),
    StringLiteral(StringLiteral),
}
pub type Identifier = String;
pub type IdentifierChar = char;
#[allow(non_camel_case_types)]
#[derive(Debug, Clone)]
pub enum StringItem {
    HexaEscape(HexaEscape),
    SimpleEscape(SimpleEscape),
    Utf8Escape(Utf8Escape),
    char(char),
}
#[allow(non_camel_case_types)]
#[derive(Debug, Clone)]
pub enum SimpleEscape {
    SimpleEscapeBackslash(SimpleEscapeBackslash),
    SimpleEscapeCarriageReturn(SimpleEscapeCarriageReturn),
    SimpleEscapeDQuote(SimpleEscapeDQuote),
    SimpleEscapeNewline(SimpleEscapeNewline),
    SimpleEscapeQuote(SimpleEscapeQuote),
    SimpleEscapeTab(SimpleEscapeTab),
}
#[derive(Debug, Clone)]
pub struct SimpleEscapeNewline;
#[derive(Debug, Clone)]
pub struct SimpleEscapeCarriageReturn;
#[derive(Debug, Clone)]
pub struct SimpleEscapeTab;
#[derive(Debug, Clone)]
pub struct SimpleEscapeBackslash;
#[derive(Debug, Clone)]
pub struct SimpleEscapeQuote;
#[derive(Debug, Clone)]
pub struct SimpleEscapeDQuote;
#[derive(Debug, Clone)]
pub struct HexaEscape {
    pub c1: HexChar,
    pub c2: HexChar,
}
pub type HexChar = char;
#[derive(Debug, Clone)]
pub struct Utf8Escape {
    pub c1: HexChar,
    pub c2: Option<HexChar>,
    pub c3: Option<HexChar>,
    pub c4: Option<HexChar>,
    pub c5: Option<HexChar>,
    pub c6: Option<HexChar>,
}
#[allow(non_camel_case_types)]
#[derive(Debug, Clone)]
pub enum DirectiveExpression {
    CheckDirective(CheckDirective),
    ExportDirective(ExportDirective),
    LeftrecDirective(LeftrecDirective),
    MemoizeDirective(MemoizeDirective),
    NoSkipWsDirective(NoSkipWsDirective),
    PositionDirective(PositionDirective),
    StringDirective(StringDirective),
}
#[derive(Debug, Clone)]
pub struct StringDirective;
#[derive(Debug, Clone)]
pub struct CharDirective;
#[derive(Debug, Clone)]
pub struct NoSkipWsDirective;
#[derive(Debug, Clone)]
pub struct ExportDirective;
#[derive(Debug, Clone)]
pub struct PositionDirective;
#[derive(Debug, Clone)]
pub struct MemoizeDirective;
#[derive(Debug, Clone)]
pub struct LeftrecDirective;
#[derive(Debug, Clone)]
pub struct CheckDirective {
    pub function: NamespacedRustName,
}
#[derive(Debug, Clone)]
pub struct ExternDirective {
    pub function: NamespacedRustName,
    pub return_type: Option<NamespacedRustName>,
}
pub type NamespacedRustName = Vec<RustNamePart>;
pub type RustNamePart = String;
#[derive(Debug, Clone)]
pub struct EndOfInput;
#[derive(Debug, Clone)]
pub struct Whitespace;
#[derive(Debug, Clone)]
pub struct Comment;
impl peginator_generated::PegParserAdvanced<()> for Grammar {
    fn parse_advanced<TT: peginator_generated::ParseTracer>(
        s: &str,
        settings: &peginator_generated::ParseSettings,
        user_context: (),
    ) -> Result<Self, peginator_generated::ParseError> {
        Ok(peginator_generated::parse_Grammar(
            peginator_generated::ParseState::new(s, settings),
            &mut peginator_generated::ParseGlobal::<TT, peginator_generated::ParseCache, ()>::new(
                Default::default(),
                user_context,
            ),
        )?
        .result)
    }
}
#[allow(
    non_snake_case,
    unused_variables,
    unused_imports,
    unused_mut,
    dead_code
)]
mod peginator_generated {
    use super::*;
    use peginator::*;
    pub use peginator::{
        IndentedTracer, ParseError, ParseGlobal, ParseSettings, ParseState, ParseTracer, PegParser,
        PegParserAdvanced, PegPosition,
    };
    #[derive(Default)]
    pub struct ParseCache<'a> {
        _please_dont_complain: std::marker::PhantomData<&'a ()>,
    }
    mod Grammar_impl {
        use super::*;
        mod part_0 {
            use super::*;
            mod closure {
                use super::*;
                #[inline(always)]
                pub fn parse<'a, TT: ParseTracer>(
                    state: ParseState<'a>,
                    global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
                ) -> ParseResult<'a, Parsed> {
                    let ParseOk {
                        result: mut rules,
                        state,
                    } = ChoiceHelper::new(state)
                        .choice(|state| {
                            parse_Whitespace(state, &mut *global)
                                .and_then(|ParseOk { state, .. }| parse_Rule(state, &mut *global))
                                .map_inner(Parsed_rules::Rule)
                                .map_inner(|result| vec![result])
                        })
                        .choice(|state| {
                            parse_Whitespace(state, &mut *global)
                                .and_then(|ParseOk { state, .. }| {
                                    parse_CharRule(state, &mut *global)
                                })
                                .map_inner(Parsed_rules::CharRule)
                                .map_inner(|result| vec![result])
                        })
                        .choice(|state| {
                            parse_Whitespace(state, &mut *global)
                                .and_then(|ParseOk { state, .. }| {
                                    parse_ExternRule(state, &mut *global)
                                })
                                .map_inner(Parsed_rules::ExternRule)
                                .map_inner(|result| vec![result])
                        })
                        .end()?;
                    let ParseOk { state, .. } = parse_Whitespace(state, &mut *global)
                        .and_then(|ParseOk { state, .. }| parse_character_literal(state, ';'))
                        .discard_result()?;
                    Ok(ParseOk {
                        result: rules,
                        state,
                    })
                }
                pub type Parsed = Vec<Parsed_rules>;
            }
            #[inline(always)]
            pub fn parse<'a, TT: ParseTracer>(
                state: ParseState<'a>,
                global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
            ) -> ParseResult<'a, Parsed> {
                let mut iterations: usize = 0;
                let mut state = state;
                let mut rules: Vec<Parsed_rules> = Vec::new();
                loop {
                    match closure::parse(state.clone(), global) {
                        Ok(ParseOk {
                            result: __result,
                            state: new_state,
                            ..
                        }) => {
                            rules.extend(__result);
                            state = new_state;
                        }
                        Err(err) => {
                            state = state.record_error(err);
                            break;
                        }
                    }
                    iterations += 1;
                }
                Ok(ParseOk {
                    result: rules,
                    state,
                })
            }
            pub type Parsed = Vec<Parsed_rules>;
        }
        #[inline(always)]
        pub fn parse<'a, TT: ParseTracer>(
            state: ParseState<'a>,
            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
        ) -> ParseResult<'a, Parsed> {
            let ParseOk {
                result: mut rules,
                state,
            } = part_0::parse(state, global)?;
            let ParseOk { state, .. } = parse_Whitespace(state, &mut *global)
                .and_then(|ParseOk { state, .. }| parse_end_of_input(state))?;
            Ok(ParseOk {
                result: rules,
                state,
            })
        }
        pub type Parsed = Vec<Parsed_rules>;
        use super::Grammar_rules as Parsed_rules;
    }
    #[inline]
    pub(super) fn parse_Grammar<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, Grammar> {
        global.tracer.print_trace_start(&state, "Grammar");
        let result = (|| {
            let result = Grammar_impl::parse(state, global)?.map(|r| super::Grammar { rules: r });
            Ok(result)
        })();
        global.tracer.print_trace_result(&result);
        result
    }
    mod Rule_impl {
        use super::*;
        mod part_0 {
            use super::*;
            mod closure {
                use super::*;
            }
            #[inline(always)]
            pub fn parse<'a, TT: ParseTracer>(
                state: ParseState<'a>,
                global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
            ) -> ParseResult<'a, Parsed> {
                let mut iterations: usize = 0;
                let mut state = state;
                let mut directives: Vec<DirectiveExpression> = Vec::new();
                loop {
                    match parse_Whitespace(state.clone(), &mut *global)
                        .and_then(|ParseOk { state, .. }| {
                            parse_DirectiveExpression(state, &mut *global)
                        })
                        .map_inner(|result| vec![result])
                    {
                        Ok(ParseOk {
                            result: __result,
                            state: new_state,
                            ..
                        }) => {
                            directives.extend(__result);
                            state = new_state;
                        }
                        Err(err) => {
                            state = state.record_error(err);
                            break;
                        }
                    }
                    iterations += 1;
                }
                Ok(ParseOk {
                    result: directives,
                    state,
                })
            }
            pub type Parsed = Vec<DirectiveExpression>;
        }
        #[inline(always)]
        pub fn parse<'a, TT: ParseTracer>(
            state: ParseState<'a>,
            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
        ) -> ParseResult<'a, Parsed> {
            let ParseOk {
                result: mut directives,
                state,
            } = part_0::parse(state, global)?;
            let ParseOk {
                result: name,
                state,
            } = parse_Whitespace(state, &mut *global)
                .and_then(|ParseOk { state, .. }| parse_Identifier(state, &mut *global))?;
            let ParseOk { state, .. } = parse_Whitespace(state, &mut *global)
                .and_then(|ParseOk { state, .. }| parse_character_literal(state, '='))
                .discard_result()?;
            let ParseOk {
                result: definition,
                state,
            } = parse_Whitespace(state, &mut *global)
                .and_then(|ParseOk { state, .. }| parse_Choice(state, &mut *global))?;
            Ok(ParseOk {
                result: Parsed {
                    directives,
                    name,
                    definition,
                },
                state,
            })
        }
        pub struct Parsed {
            pub directives: Vec<DirectiveExpression>,
            pub name: Identifier,
            pub definition: Choice,
        }
    }
    #[inline]
    pub(super) fn parse_Rule<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, Rule> {
        global.tracer.print_trace_start(&state, "Rule");
        let result = (|| {
            let result = Rule_impl::parse(state, global)?.map(|r| super::Rule {
                directives: r.directives,
                name: r.name,
                definition: r.definition,
            });
            Ok(result)
        })();
        global.tracer.print_trace_result(&result);
        result
    }
    mod CharRule_impl {
        use super::*;
        mod part_0 {
            use super::*;
            mod closure {
                use super::*;
            }
            #[inline(always)]
            pub fn parse<'a, TT: ParseTracer>(
                state: ParseState<'a>,
                global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
            ) -> ParseResult<'a, Parsed> {
                let mut iterations: usize = 0;
                let mut state = state;
                let mut directives: Vec<CheckDirective> = Vec::new();
                loop {
                    match parse_Whitespace(state.clone(), &mut *global)
                        .and_then(|ParseOk { state, .. }| parse_CheckDirective(state, &mut *global))
                        .map_inner(|result| vec![result])
                    {
                        Ok(ParseOk {
                            result: __result,
                            state: new_state,
                            ..
                        }) => {
                            directives.extend(__result);
                            state = new_state;
                        }
                        Err(err) => {
                            state = state.record_error(err);
                            break;
                        }
                    }
                    iterations += 1;
                }
                Ok(ParseOk {
                    result: directives,
                    state,
                })
            }
            pub type Parsed = Vec<CheckDirective>;
        }
        mod part_2 {
            use super::*;
            mod closure {
                use super::*;
            }
            #[inline(always)]
            pub fn parse<'a, TT: ParseTracer>(
                state: ParseState<'a>,
                global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
            ) -> ParseResult<'a, Parsed> {
                let mut iterations: usize = 0;
                let mut state = state;
                let mut directives: Vec<CheckDirective> = Vec::new();
                loop {
                    match parse_Whitespace(state.clone(), &mut *global)
                        .and_then(|ParseOk { state, .. }| parse_CheckDirective(state, &mut *global))
                        .map_inner(|result| vec![result])
                    {
                        Ok(ParseOk {
                            result: __result,
                            state: new_state,
                            ..
                        }) => {
                            directives.extend(__result);
                            state = new_state;
                        }
                        Err(err) => {
                            state = state.record_error(err);
                            break;
                        }
                    }
                    iterations += 1;
                }
                Ok(ParseOk {
                    result: directives,
                    state,
                })
            }
            pub type Parsed = Vec<CheckDirective>;
        }
        mod part_6 {
            use super::*;
            mod closure {
                use super::*;
                #[inline(always)]
                pub fn parse<'a, TT: ParseTracer>(
                    state: ParseState<'a>,
                    global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
                ) -> ParseResult<'a, Parsed> {
                    let ParseOk { state, .. } = parse_Whitespace(state, &mut *global)
                        .and_then(|ParseOk { state, .. }| parse_character_literal(state, '|'))
                        .discard_result()?;
                    let ParseOk {
                        result: mut choices,
                        state,
                    } = parse_Whitespace(state, &mut *global)
                        .and_then(|ParseOk { state, .. }| parse_CharRulePart(state, &mut *global))
                        .map_inner(|result| vec![result])?;
                    Ok(ParseOk {
                        result: choices,
                        state,
                    })
                }
                pub type Parsed = Vec<CharRulePart>;
            }
            #[inline(always)]
            pub fn parse<'a, TT: ParseTracer>(
                state: ParseState<'a>,
                global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
            ) -> ParseResult<'a, Parsed> {
                let mut iterations: usize = 0;
                let mut state = state;
                let mut choices: Vec<CharRulePart> = Vec::new();
                loop {
                    match closure::parse(state.clone(), global) {
                        Ok(ParseOk {
                            result: __result,
                            state: new_state,
                            ..
                        }) => {
                            choices.extend(__result);
                            state = new_state;
                        }
                        Err(err) => {
                            state = state.record_error(err);
                            break;
                        }
                    }
                    iterations += 1;
                }
                Ok(ParseOk {
                    result: choices,
                    state,
                })
            }
            pub type Parsed = Vec<CharRulePart>;
        }
        #[inline(always)]
        pub fn parse<'a, TT: ParseTracer>(
            state: ParseState<'a>,
            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
        ) -> ParseResult<'a, Parsed> {
            let ParseOk {
                result: mut directives,
                state,
            } = part_0::parse(state, global)?;
            let ParseOk { state, .. } = parse_Whitespace(state, &mut *global)
                .and_then(|ParseOk { state, .. }| parse_CharDirective(state, &mut *global))
                .discard_result()?;
            let ParseOk {
                result: extend_directives_with,
                state,
            } = part_2::parse(state, global)?;
            directives.extend(extend_directives_with);
            let ParseOk {
                result: name,
                state,
            } = parse_Whitespace(state, &mut *global)
                .and_then(|ParseOk { state, .. }| parse_Identifier(state, &mut *global))?;
            let ParseOk { state, .. } = parse_Whitespace(state, &mut *global)
                .and_then(|ParseOk { state, .. }| parse_character_literal(state, '='))
                .discard_result()?;
            let ParseOk {
                result: mut choices,
                state,
            } = parse_Whitespace(state, &mut *global)
                .and_then(|ParseOk { state, .. }| parse_CharRulePart(state, &mut *global))
                .map_inner(|result| vec![result])?;
            let ParseOk {
                result: extend_choices_with,
                state,
            } = part_6::parse(state, global)?;
            choices.extend(extend_choices_with);
            Ok(ParseOk {
                result: Parsed {
                    directives,
                    name,
                    choices,
                },
                state,
            })
        }
        pub struct Parsed {
            pub directives: Vec<CheckDirective>,
            pub name: Identifier,
            pub choices: Vec<CharRulePart>,
        }
    }
    #[inline]
    pub(super) fn parse_CharRule<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, CharRule> {
        global.tracer.print_trace_start(&state, "CharRule");
        let result = (|| {
            let result = CharRule_impl::parse(state, global)?.map(|r| super::CharRule {
                directives: r.directives,
                name: r.name,
                choices: r.choices,
            });
            Ok(result)
        })();
        global.tracer.print_trace_result(&result);
        result
    }
    mod CharRulePart_impl {
        use super::*;
        #[inline(always)]
        pub fn parse<'a, TT: ParseTracer>(
            state: ParseState<'a>,
            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
        ) -> ParseResult<'a, Parsed> {
            ChoiceHelper::new(state)
                .choice(|state| {
                    parse_Whitespace(state, &mut *global)
                        .and_then(|ParseOk { state, .. }| parse_CharacterRange(state, &mut *global))
                        .map_inner(Parsed__override::CharacterRange)
                })
                .choice(|state| {
                    parse_Whitespace(state, &mut *global)
                        .and_then(|ParseOk { state, .. }| parse_CharRangePart(state, &mut *global))
                        .map_inner(Parsed__override::CharRangePart)
                })
                .choice(|state| {
                    parse_Whitespace(state, &mut *global)
                        .and_then(|ParseOk { state, .. }| parse_Identifier(state, &mut *global))
                        .map_inner(Parsed__override::Identifier)
                })
                .end()
        }
        pub type Parsed = Parsed__override;
        use super::CharRulePart as Parsed__override;
    }
    #[inline]
    pub(super) fn parse_CharRulePart<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, CharRulePart> {
        global.tracer.print_trace_start(&state, "CharRulePart");
        let result = (|| {
            let result = CharRulePart_impl::parse(state, global)?;
            Ok(result)
        })();
        global.tracer.print_trace_result(&result);
        result
    }
    mod ExternRule_impl {
        use super::*;
        #[inline(always)]
        pub fn parse<'a, TT: ParseTracer>(
            state: ParseState<'a>,
            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
        ) -> ParseResult<'a, Parsed> {
            let ParseOk {
                result: directive,
                state,
            } = parse_Whitespace(state, &mut *global)
                .and_then(|ParseOk { state, .. }| parse_ExternDirective(state, &mut *global))?;
            let ParseOk {
                result: name,
                state,
            } = parse_Whitespace(state, &mut *global)
                .and_then(|ParseOk { state, .. }| parse_Identifier(state, &mut *global))?;
            Ok(ParseOk {
                result: Parsed { directive, name },
                state,
            })
        }
        pub struct Parsed {
            pub directive: ExternDirective,
            pub name: Identifier,
        }
    }
    #[inline]
    pub(super) fn parse_ExternRule<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, ExternRule> {
        global.tracer.print_trace_start(&state, "ExternRule");
        let result = (|| {
            let result = ExternRule_impl::parse(state, global)?.map(|r| super::ExternRule {
                directive: r.directive,
                name: r.name,
            });
            Ok(result)
        })();
        global.tracer.print_trace_result(&result);
        result
    }
    mod Choice_impl {
        use super::*;
        mod part_1 {
            use super::*;
            mod closure {
                use super::*;
                #[inline(always)]
                pub fn parse<'a, TT: ParseTracer>(
                    state: ParseState<'a>,
                    global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
                ) -> ParseResult<'a, Parsed> {
                    let ParseOk { state, .. } = parse_Whitespace(state, &mut *global)
                        .and_then(|ParseOk { state, .. }| parse_character_literal(state, '|'))
                        .discard_result()?;
                    let ParseOk {
                        result: mut choices,
                        state,
                    } = parse_Whitespace(state, &mut *global)
                        .and_then(|ParseOk { state, .. }| parse_Sequence(state, &mut *global))
                        .map_inner(|result| vec![result])?;
                    Ok(ParseOk {
                        result: choices,
                        state,
                    })
                }
                pub type Parsed = Vec<Sequence>;
            }
            #[inline(always)]
            pub fn parse<'a, TT: ParseTracer>(
                state: ParseState<'a>,
                global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
            ) -> ParseResult<'a, Parsed> {
                let mut iterations: usize = 0;
                let mut state = state;
                let mut choices: Vec<Sequence> = Vec::new();
                loop {
                    match closure::parse(state.clone(), global) {
                        Ok(ParseOk {
                            result: __result,
                            state: new_state,
                            ..
                        }) => {
                            choices.extend(__result);
                            state = new_state;
                        }
                        Err(err) => {
                            state = state.record_error(err);
                            break;
                        }
                    }
                    iterations += 1;
                }
                Ok(ParseOk {
                    result: choices,
                    state,
                })
            }
            pub type Parsed = Vec<Sequence>;
        }
        #[inline(always)]
        pub fn parse<'a, TT: ParseTracer>(
            state: ParseState<'a>,
            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
        ) -> ParseResult<'a, Parsed> {
            let ParseOk {
                result: mut choices,
                state,
            } = parse_Whitespace(state, &mut *global)
                .and_then(|ParseOk { state, .. }| parse_Sequence(state, &mut *global))
                .map_inner(|result| vec![result])?;
            let ParseOk {
                result: extend_choices_with,
                state,
            } = part_1::parse(state, global)?;
            choices.extend(extend_choices_with);
            Ok(ParseOk {
                result: choices,
                state,
            })
        }
        pub type Parsed = Vec<Sequence>;
    }
    #[inline]
    pub(super) fn parse_Choice<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, Choice> {
        global.tracer.print_trace_start(&state, "Choice");
        let result = (|| {
            let result = Choice_impl::parse(state, global)?.map(|r| super::Choice { choices: r });
            Ok(result)
        })();
        global.tracer.print_trace_result(&result);
        result
    }
    mod Sequence_impl {
        use super::*;
        mod closure {
            use super::*;
        }
        #[inline(always)]
        pub fn parse<'a, TT: ParseTracer>(
            state: ParseState<'a>,
            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
        ) -> ParseResult<'a, Parsed> {
            let mut iterations: usize = 0;
            let mut state = state;
            let mut parts: Vec<DelimitedExpression> = Vec::new();
            loop {
                match parse_Whitespace(state.clone(), &mut *global)
                    .and_then(|ParseOk { state, .. }| {
                        parse_DelimitedExpression(state, &mut *global)
                    })
                    .map_inner(|result| vec![result])
                {
                    Ok(ParseOk {
                        result: __result,
                        state: new_state,
                        ..
                    }) => {
                        parts.extend(__result);
                        state = new_state;
                    }
                    Err(err) => {
                        state = state.record_error(err);
                        break;
                    }
                }
                iterations += 1;
            }
            Ok(ParseOk {
                result: parts,
                state,
            })
        }
        pub type Parsed = Vec<DelimitedExpression>;
    }
    #[inline]
    pub(super) fn parse_Sequence<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, Sequence> {
        global.tracer.print_trace_start(&state, "Sequence");
        let result = (|| {
            let result = Sequence_impl::parse(state, global)?.map(|r| super::Sequence { parts: r });
            Ok(result)
        })();
        global.tracer.print_trace_result(&result);
        result
    }
    mod Group_impl {
        use super::*;
        #[inline(always)]
        pub fn parse<'a, TT: ParseTracer>(
            state: ParseState<'a>,
            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
        ) -> ParseResult<'a, Parsed> {
            let ParseOk { state, .. } = parse_Whitespace(state, &mut *global)
                .and_then(|ParseOk { state, .. }| parse_character_literal(state, '('))
                .discard_result()?;
            let ParseOk {
                result: body,
                state,
            } = parse_Whitespace(state, &mut *global)
                .and_then(|ParseOk { state, .. }| parse_Choice(state, &mut *global))?;
            let ParseOk { state, .. } = parse_Whitespace(state, &mut *global)
                .and_then(|ParseOk { state, .. }| parse_character_literal(state, ')'))
                .discard_result()?;
            Ok(ParseOk {
                result: body,
                state,
            })
        }
        pub type Parsed = Choice;
    }
    #[inline]
    pub(super) fn parse_Group<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, Group> {
        global.tracer.print_trace_start(&state, "Group");
        let result = (|| {
            let result = Group_impl::parse(state, global)?.map(|r| super::Group { body: r });
            Ok(result)
        })();
        global.tracer.print_trace_result(&result);
        result
    }
    mod Optional_impl {
        use super::*;
        #[inline(always)]
        pub fn parse<'a, TT: ParseTracer>(
            state: ParseState<'a>,
            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
        ) -> ParseResult<'a, Parsed> {
            let ParseOk { state, .. } = parse_Whitespace(state, &mut *global)
                .and_then(|ParseOk { state, .. }| parse_character_literal(state, '['))
                .discard_result()?;
            let ParseOk {
                result: body,
                state,
            } = parse_Whitespace(state, &mut *global)
                .and_then(|ParseOk { state, .. }| parse_Choice(state, &mut *global))?;
            let ParseOk { state, .. } = parse_Whitespace(state, &mut *global)
                .and_then(|ParseOk { state, .. }| parse_character_literal(state, ']'))
                .discard_result()?;
            Ok(ParseOk {
                result: body,
                state,
            })
        }
        pub type Parsed = Choice;
    }
    #[inline]
    pub(super) fn parse_Optional<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, Optional> {
        global.tracer.print_trace_start(&state, "Optional");
        let result = (|| {
            let result = Optional_impl::parse(state, global)?.map(|r| super::Optional { body: r });
            Ok(result)
        })();
        global.tracer.print_trace_result(&result);
        result
    }
    mod Closure_impl {
        use super::*;
        #[inline(always)]
        pub fn parse<'a, TT: ParseTracer>(
            state: ParseState<'a>,
            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
        ) -> ParseResult<'a, Parsed> {
            let ParseOk { state, .. } = parse_Whitespace(state, &mut *global)
                .and_then(|ParseOk { state, .. }| parse_character_literal(state, '{'))
                .discard_result()?;
            let ParseOk {
                result: body,
                state,
            } = parse_Whitespace(state, &mut *global)
                .and_then(|ParseOk { state, .. }| parse_Choice(state, &mut *global))?;
            let ParseOk { state, .. } = parse_Whitespace(state, &mut *global)
                .and_then(|ParseOk { state, .. }| parse_character_literal(state, '}'))
                .discard_result()?;
            let ParseOk {
                result: at_least_one,
                state,
            } = parse_Whitespace(state.clone(), &mut *global)
                .and_then(|ParseOk { state, .. }| parse_AtLeastOneMarker(state, &mut *global))
                .map_inner(Some)
                .or_else(|err| {
                    Ok(ParseOk {
                        result: Default::default(),
                        state: state.record_error(err),
                    })
                })?;
            Ok(ParseOk {
                result: Parsed { body, at_least_one },
                state,
            })
        }
        pub struct Parsed {
            pub body: Choice,
            pub at_least_one: Option<AtLeastOneMarker>,
        }
    }
    #[inline]
    pub(super) fn parse_Closure<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, Closure> {
        global.tracer.print_trace_start(&state, "Closure");
        let result = (|| {
            let result = Closure_impl::parse(state, global)?.map(|r| super::Closure {
                body: r.body,
                at_least_one: r.at_least_one,
            });
            Ok(result)
        })();
        global.tracer.print_trace_result(&result);
        result
    }
    mod AtLeastOneMarker_impl {
        use super::*;
        #[inline(always)]
        pub fn parse<'a, TT: ParseTracer>(
            state: ParseState<'a>,
            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
        ) -> ParseResult<'a, Parsed> {
            parse_Whitespace(state, &mut *global)
                .and_then(|ParseOk { state, .. }| parse_character_literal(state, '+'))
                .discard_result()
        }
        pub type Parsed = ();
    }
    #[inline]
    pub(super) fn parse_AtLeastOneMarker<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, AtLeastOneMarker> {
        global.tracer.print_trace_start(&state, "AtLeastOneMarker");
        let result = (|| {
            let result =
                AtLeastOneMarker_impl::parse(state, global)?.map(|r| super::AtLeastOneMarker {});
            Ok(result)
        })();
        global.tracer.print_trace_result(&result);
        result
    }
    mod NegativeLookahead_impl {
        use super::*;
        #[inline(always)]
        pub fn parse<'a, TT: ParseTracer>(
            state: ParseState<'a>,
            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
        ) -> ParseResult<'a, Parsed> {
            let ParseOk { state, .. } = parse_Whitespace(state, &mut *global)
                .and_then(|ParseOk { state, .. }| parse_character_literal(state, '!'))
                .discard_result()?;
            let ParseOk {
                result: expr,
                state,
            } = parse_Whitespace(state, &mut *global)
                .and_then(|ParseOk { state, .. }| parse_DelimitedExpression(state, &mut *global))
                .map_inner(Box::new)?;
            Ok(ParseOk {
                result: expr,
                state,
            })
        }
        pub type Parsed = Box<DelimitedExpression>;
    }
    #[inline]
    pub(super) fn parse_NegativeLookahead<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, NegativeLookahead> {
        global.tracer.print_trace_start(&state, "NegativeLookahead");
        let result = (|| {
            let result = NegativeLookahead_impl::parse(state, global)?
                .map(|r| super::NegativeLookahead { expr: r });
            Ok(result)
        })();
        global.tracer.print_trace_result(&result);
        result
    }
    mod PositiveLookahead_impl {
        use super::*;
        #[inline(always)]
        pub fn parse<'a, TT: ParseTracer>(
            state: ParseState<'a>,
            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
        ) -> ParseResult<'a, Parsed> {
            let ParseOk { state, .. } = parse_Whitespace(state, &mut *global)
                .and_then(|ParseOk { state, .. }| parse_character_literal(state, '&'))
                .discard_result()?;
            let ParseOk {
                result: expr,
                state,
            } = parse_Whitespace(state, &mut *global)
                .and_then(|ParseOk { state, .. }| parse_DelimitedExpression(state, &mut *global))
                .map_inner(Box::new)?;
            Ok(ParseOk {
                result: expr,
                state,
            })
        }
        pub type Parsed = Box<DelimitedExpression>;
    }
    #[inline]
    pub(super) fn parse_PositiveLookahead<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, PositiveLookahead> {
        global.tracer.print_trace_start(&state, "PositiveLookahead");
        let result = (|| {
            let result = PositiveLookahead_impl::parse(state, global)?
                .map(|r| super::PositiveLookahead { expr: r });
            Ok(result)
        })();
        global.tracer.print_trace_result(&result);
        result
    }
    mod CharacterRange_impl {
        use super::*;
        #[inline(always)]
        pub fn parse<'a, TT: ParseTracer>(
            state: ParseState<'a>,
            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
        ) -> ParseResult<'a, Parsed> {
            let ParseOk {
                result: from,
                state,
            } = parse_Whitespace(state, &mut *global)
                .and_then(|ParseOk { state, .. }| parse_CharRangePart(state, &mut *global))?;
            let ParseOk { state, .. } = parse_Whitespace(state, &mut *global)
                .and_then(|ParseOk { state, .. }| parse_string_literal(state, ".."))
                .discard_result()?;
            let ParseOk { result: to, state } = parse_Whitespace(state, &mut *global)
                .and_then(|ParseOk { state, .. }| parse_CharRangePart(state, &mut *global))?;
            Ok(ParseOk {
                result: Parsed { from, to },
                state,
            })
        }
        pub struct Parsed {
            pub from: CharRangePart,
            pub to: CharRangePart,
        }
    }
    #[inline]
    pub(super) fn parse_CharacterRange<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, CharacterRange> {
        global.tracer.print_trace_start(&state, "CharacterRange");
        let result = (|| {
            let result =
                CharacterRange_impl::parse(state, global)?.map(|r| super::CharacterRange {
                    from: r.from,
                    to: r.to,
                });
            Ok(result)
        })();
        global.tracer.print_trace_result(&result);
        result
    }
    mod CharRangePart_impl {
        use super::*;
        #[inline(always)]
        pub fn parse<'a, TT: ParseTracer>(
            state: ParseState<'a>,
            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
        ) -> ParseResult<'a, Parsed> {
            let ParseOk { state, .. } = parse_character_literal(state, '\'').discard_result()?;
            let ParseOk {
                result: _override,
                state,
            } = parse_StringItem(state, &mut *global)?;
            let ParseOk { state, .. } = parse_character_literal(state, '\'').discard_result()?;
            Ok(ParseOk {
                result: _override,
                state,
            })
        }
        pub type Parsed = StringItem;
        use super::CharRangePart as Parsed__override;
    }
    #[inline]
    pub(super) fn parse_CharRangePart<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, CharRangePart> {
        global.tracer.print_trace_start(&state, "CharRangePart");
        let result = (|| {
            let result = CharRangePart_impl::parse(state, global)?;
            Ok(result)
        })();
        global.tracer.print_trace_result(&result);
        result
    }
    mod StringLiteral_impl {
        use super::*;
        mod part_1 {
            use super::*;
            mod choice_0 {
                use super::*;
                mod part_1 {
                    use super::*;
                    mod closure {
                        use super::*;
                        mod part_0 {
                            use super::*;
                            mod negative_lookahead {
                                use super::*;
                                #[inline(always)]
                                pub fn parse<'a, TT: ParseTracer>(
                                    state: ParseState<'a>,
                                    global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
                                ) -> ParseResult<'a, Parsed> {
                                    parse_character_literal(state, '"').discard_result()
                                }
                                pub type Parsed = ();
                            }
                            #[inline(always)]
                            pub fn parse<'a, TT: ParseTracer>(
                                state: ParseState<'a>,
                                global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
                            ) -> ParseResult<'a, Parsed> {
                                match negative_lookahead::parse(state.clone(), global) {
                                    Ok(_) => Err(state.report_error(
                                        ParseErrorSpecifics::NegativeLookaheadFailed,
                                    )),
                                    Err(_) => Ok(ParseOk { result: (), state }),
                                }
                            }
                            pub type Parsed = ();
                        }
                        #[inline(always)]
                        pub fn parse<'a, TT: ParseTracer>(
                            state: ParseState<'a>,
                            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
                        ) -> ParseResult<'a, Parsed> {
                            let ParseOk { state, .. } = part_0::parse(state, global)?;
                            let ParseOk {
                                result: mut body,
                                state,
                            } = parse_StringItem(state, &mut *global)
                                .map_inner(|result| vec![result])?;
                            Ok(ParseOk {
                                result: body,
                                state,
                            })
                        }
                        pub type Parsed = Vec<StringItem>;
                    }
                    #[inline(always)]
                    pub fn parse<'a, TT: ParseTracer>(
                        state: ParseState<'a>,
                        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
                    ) -> ParseResult<'a, Parsed> {
                        let mut iterations: usize = 0;
                        let mut state = state;
                        let mut body: Vec<StringItem> = Vec::new();
                        loop {
                            match closure::parse(state.clone(), global) {
                                Ok(ParseOk {
                                    result: __result,
                                    state: new_state,
                                    ..
                                }) => {
                                    body.extend(__result);
                                    state = new_state;
                                }
                                Err(err) => {
                                    state = state.record_error(err);
                                    break;
                                }
                            }
                            iterations += 1;
                        }
                        Ok(ParseOk {
                            result: body,
                            state,
                        })
                    }
                    pub type Parsed = Vec<StringItem>;
                }
                #[inline(always)]
                pub fn parse<'a, TT: ParseTracer>(
                    state: ParseState<'a>,
                    global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
                ) -> ParseResult<'a, Parsed> {
                    let ParseOk { state, .. } =
                        parse_character_literal(state, '"').discard_result()?;
                    let ParseOk {
                        result: mut body,
                        state,
                    } = part_1::parse(state, global)?;
                    let ParseOk { state, .. } =
                        parse_character_literal(state, '"').discard_result()?;
                    Ok(ParseOk {
                        result: body,
                        state,
                    })
                }
                pub type Parsed = Vec<StringItem>;
            }
            mod choice_1 {
                use super::*;
                mod part_1 {
                    use super::*;
                    mod closure {
                        use super::*;
                        mod part_0 {
                            use super::*;
                            mod negative_lookahead {
                                use super::*;
                                #[inline(always)]
                                pub fn parse<'a, TT: ParseTracer>(
                                    state: ParseState<'a>,
                                    global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
                                ) -> ParseResult<'a, Parsed> {
                                    parse_character_literal(state, '\'').discard_result()
                                }
                                pub type Parsed = ();
                            }
                            #[inline(always)]
                            pub fn parse<'a, TT: ParseTracer>(
                                state: ParseState<'a>,
                                global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
                            ) -> ParseResult<'a, Parsed> {
                                match negative_lookahead::parse(state.clone(), global) {
                                    Ok(_) => Err(state.report_error(
                                        ParseErrorSpecifics::NegativeLookaheadFailed,
                                    )),
                                    Err(_) => Ok(ParseOk { result: (), state }),
                                }
                            }
                            pub type Parsed = ();
                        }
                        #[inline(always)]
                        pub fn parse<'a, TT: ParseTracer>(
                            state: ParseState<'a>,
                            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
                        ) -> ParseResult<'a, Parsed> {
                            let ParseOk { state, .. } = part_0::parse(state, global)?;
                            let ParseOk {
                                result: mut body,
                                state,
                            } = parse_StringItem(state, &mut *global)
                                .map_inner(|result| vec![result])?;
                            Ok(ParseOk {
                                result: body,
                                state,
                            })
                        }
                        pub type Parsed = Vec<StringItem>;
                    }
                    #[inline(always)]
                    pub fn parse<'a, TT: ParseTracer>(
                        state: ParseState<'a>,
                        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
                    ) -> ParseResult<'a, Parsed> {
                        let mut iterations: usize = 0;
                        let mut state = state;
                        let mut body: Vec<StringItem> = Vec::new();
                        loop {
                            match closure::parse(state.clone(), global) {
                                Ok(ParseOk {
                                    result: __result,
                                    state: new_state,
                                    ..
                                }) => {
                                    body.extend(__result);
                                    state = new_state;
                                }
                                Err(err) => {
                                    state = state.record_error(err);
                                    break;
                                }
                            }
                            iterations += 1;
                        }
                        Ok(ParseOk {
                            result: body,
                            state,
                        })
                    }
                    pub type Parsed = Vec<StringItem>;
                }
                #[inline(always)]
                pub fn parse<'a, TT: ParseTracer>(
                    state: ParseState<'a>,
                    global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
                ) -> ParseResult<'a, Parsed> {
                    let ParseOk { state, .. } =
                        parse_character_literal(state, '\'').discard_result()?;
                    let ParseOk {
                        result: mut body,
                        state,
                    } = part_1::parse(state, global)?;
                    let ParseOk { state, .. } =
                        parse_character_literal(state, '\'').discard_result()?;
                    Ok(ParseOk {
                        result: body,
                        state,
                    })
                }
                pub type Parsed = Vec<StringItem>;
            }
            #[inline(always)]
            pub fn parse<'a, TT: ParseTracer>(
                state: ParseState<'a>,
                global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
            ) -> ParseResult<'a, Parsed> {
                ChoiceHelper::new(state)
                    .choice(|state| choice_0::parse(state, global))
                    .choice(|state| choice_1::parse(state, global))
                    .end()
            }
            pub type Parsed = Vec<StringItem>;
        }
        #[inline(always)]
        pub fn parse<'a, TT: ParseTracer>(
            state: ParseState<'a>,
            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
        ) -> ParseResult<'a, Parsed> {
            let ParseOk {
                result: insensitive,
                state,
            } = parse_CaseInsensitiveMarker(state.clone(), &mut *global)
                .map_inner(Some)
                .or_else(|err| {
                    Ok(ParseOk {
                        result: Default::default(),
                        state: state.record_error(err),
                    })
                })?;
            let ParseOk {
                result: mut body,
                state,
            } = part_1::parse(state, global)?;
            Ok(ParseOk {
                result: Parsed { insensitive, body },
                state,
            })
        }
        pub struct Parsed {
            pub insensitive: Option<CaseInsensitiveMarker>,
            pub body: Vec<StringItem>,
        }
    }
    #[inline]
    pub(super) fn parse_StringLiteral<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, StringLiteral> {
        global.tracer.print_trace_start(&state, "StringLiteral");
        let result = (|| {
            let result = StringLiteral_impl::parse(state, global)?.map(|r| super::StringLiteral {
                insensitive: r.insensitive,
                body: r.body,
            });
            Ok(result)
        })();
        global.tracer.print_trace_result(&result);
        result
    }
    mod CaseInsensitiveMarker_impl {
        use super::*;
        #[inline(always)]
        pub fn parse<'a, TT: ParseTracer>(
            state: ParseState<'a>,
            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
        ) -> ParseResult<'a, Parsed> {
            parse_Whitespace(state, &mut *global)
                .and_then(|ParseOk { state, .. }| parse_character_literal(state, 'i'))
                .discard_result()
        }
        pub type Parsed = ();
    }
    #[inline]
    pub(super) fn parse_CaseInsensitiveMarker<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, CaseInsensitiveMarker> {
        global
            .tracer
            .print_trace_start(&state, "CaseInsensitiveMarker");
        let result = (|| {
            let result = CaseInsensitiveMarker_impl::parse(state, global)?
                .map(|r| super::CaseInsensitiveMarker {});
            Ok(result)
        })();
        global.tracer.print_trace_result(&result);
        result
    }
    mod Field_impl {
        use super::*;
        mod part_0 {
            use super::*;
            mod optional {
                use super::*;
                #[inline(always)]
                pub fn parse<'a, TT: ParseTracer>(
                    state: ParseState<'a>,
                    global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
                ) -> ParseResult<'a, Parsed> {
                    let ParseOk {
                        result: name,
                        state,
                    } = ChoiceHelper::new(state)
                        .choice(|state| {
                            parse_Whitespace(state, &mut *global)
                                .and_then(|ParseOk { state, .. }| {
                                    parse_Identifier(state, &mut *global)
                                })
                                .map_inner(Parsed_name::Identifier)
                                .map_inner(Some)
                        })
                        .choice(|state| {
                            parse_Whitespace(state, &mut *global)
                                .and_then(|ParseOk { state, .. }| {
                                    parse_OverrideMarker(state, &mut *global)
                                })
                                .map_inner(Parsed_name::OverrideMarker)
                                .map_inner(Some)
                        })
                        .end()?;
                    let ParseOk { state, .. } = parse_Whitespace(state, &mut *global)
                        .and_then(|ParseOk { state, .. }| parse_character_literal(state, ':'))
                        .discard_result()?;
                    let ParseOk {
                        result: boxed,
                        state,
                    } = parse_Whitespace(state.clone(), &mut *global)
                        .and_then(|ParseOk { state, .. }| parse_BoxMarker(state, &mut *global))
                        .map_inner(Some)
                        .or_else(|err| {
                            Ok(ParseOk {
                                result: Default::default(),
                                state: state.record_error(err),
                            })
                        })?;
                    Ok(ParseOk {
                        result: Parsed { name, boxed },
                        state,
                    })
                }
                pub struct Parsed {
                    pub name: Option<Parsed_name>,
                    pub boxed: Option<BoxMarker>,
                }
            }
            #[inline(always)]
            pub fn parse<'a, TT: ParseTracer>(
                state: ParseState<'a>,
                global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
            ) -> ParseResult<'a, Parsed> {
                optional::parse(state.clone(), global)
                    .map_inner(|result| Parsed {
                        name: result.name,
                        boxed: result.boxed,
                    })
                    .or_else(|err| {
                        Ok(ParseOk {
                            result: Parsed {
                                name: Default::default(),
                                boxed: Default::default(),
                            },
                            state: state.record_error(err),
                        })
                    })
            }
            pub struct Parsed {
                pub name: Option<Parsed_name>,
                pub boxed: Option<BoxMarker>,
            }
        }
        #[inline(always)]
        pub fn parse<'a, TT: ParseTracer>(
            state: ParseState<'a>,
            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
        ) -> ParseResult<'a, Parsed> {
            let ParseOk {
                result: part_0::Parsed { name, boxed },
                state,
            } = part_0::parse(state, global)?;
            let ParseOk { result: typ, state } = parse_Whitespace(state, &mut *global)
                .and_then(|ParseOk { state, .. }| parse_Identifier(state, &mut *global))?;
            Ok(ParseOk {
                result: Parsed { name, boxed, typ },
                state,
            })
        }
        pub struct Parsed {
            pub name: Option<Parsed_name>,
            pub boxed: Option<BoxMarker>,
            pub typ: Identifier,
        }
        use super::Field_name as Parsed_name;
    }
    #[inline]
    pub(super) fn parse_Field<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, Field> {
        global.tracer.print_trace_start(&state, "Field");
        let result = (|| {
            let result = Field_impl::parse(state, global)?.map(|r| super::Field {
                name: r.name,
                boxed: r.boxed,
                typ: r.typ,
            });
            Ok(result)
        })();
        global.tracer.print_trace_result(&result);
        result
    }
    mod BoxMarker_impl {
        use super::*;
        #[inline(always)]
        pub fn parse<'a, TT: ParseTracer>(
            state: ParseState<'a>,
            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
        ) -> ParseResult<'a, Parsed> {
            parse_Whitespace(state, &mut *global)
                .and_then(|ParseOk { state, .. }| parse_character_literal(state, '*'))
                .discard_result()
        }
        pub type Parsed = ();
    }
    #[inline]
    pub(super) fn parse_BoxMarker<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, BoxMarker> {
        global.tracer.print_trace_start(&state, "BoxMarker");
        let result = (|| {
            let result = BoxMarker_impl::parse(state, global)?.map(|r| super::BoxMarker {});
            Ok(result)
        })();
        global.tracer.print_trace_result(&result);
        result
    }
    mod OverrideMarker_impl {
        use super::*;
        #[inline(always)]
        pub fn parse<'a, TT: ParseTracer>(
            state: ParseState<'a>,
            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
        ) -> ParseResult<'a, Parsed> {
            parse_Whitespace(state, &mut *global)
                .and_then(|ParseOk { state, .. }| parse_character_literal(state, '@'))
                .discard_result()
        }
        pub type Parsed = ();
    }
    #[inline]
    pub(super) fn parse_OverrideMarker<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, OverrideMarker> {
        global.tracer.print_trace_start(&state, "OverrideMarker");
        let result = (|| {
            let result =
                OverrideMarker_impl::parse(state, global)?.map(|r| super::OverrideMarker {});
            Ok(result)
        })();
        global.tracer.print_trace_result(&result);
        result
    }
    mod IncludeRule_impl {
        use super::*;
        #[inline(always)]
        pub fn parse<'a, TT: ParseTracer>(
            state: ParseState<'a>,
            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
        ) -> ParseResult<'a, Parsed> {
            let ParseOk { state, .. } = parse_Whitespace(state, &mut *global)
                .and_then(|ParseOk { state, .. }| parse_character_literal(state, '>'))
                .discard_result()?;
            let ParseOk {
                result: rule,
                state,
            } = parse_Whitespace(state, &mut *global)
                .and_then(|ParseOk { state, .. }| parse_Identifier(state, &mut *global))?;
            Ok(ParseOk {
                result: rule,
                state,
            })
        }
        pub type Parsed = Identifier;
    }
    #[inline]
    pub(super) fn parse_IncludeRule<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, IncludeRule> {
        global.tracer.print_trace_start(&state, "IncludeRule");
        let result = (|| {
            let result =
                IncludeRule_impl::parse(state, global)?.map(|r| super::IncludeRule { rule: r });
            Ok(result)
        })();
        global.tracer.print_trace_result(&result);
        result
    }
    mod DelimitedExpression_impl {
        use super::*;
        #[inline(always)]
        pub fn parse<'a, TT: ParseTracer>(
            state: ParseState<'a>,
            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
        ) -> ParseResult<'a, Parsed> {
            ChoiceHelper::new(state)
                .choice(|state| {
                    parse_Whitespace(state, &mut *global)
                        .and_then(|ParseOk { state, .. }| parse_Group(state, &mut *global))
                        .map_inner(Parsed__override::Group)
                })
                .choice(|state| {
                    parse_Whitespace(state, &mut *global)
                        .and_then(|ParseOk { state, .. }| parse_Optional(state, &mut *global))
                        .map_inner(Parsed__override::Optional)
                })
                .choice(|state| {
                    parse_Whitespace(state, &mut *global)
                        .and_then(|ParseOk { state, .. }| parse_Closure(state, &mut *global))
                        .map_inner(Parsed__override::Closure)
                })
                .choice(|state| {
                    parse_Whitespace(state, &mut *global)
                        .and_then(|ParseOk { state, .. }| {
                            parse_NegativeLookahead(state, &mut *global)
                        })
                        .map_inner(Parsed__override::NegativeLookahead)
                })
                .choice(|state| {
                    parse_Whitespace(state, &mut *global)
                        .and_then(|ParseOk { state, .. }| {
                            parse_PositiveLookahead(state, &mut *global)
                        })
                        .map_inner(Parsed__override::PositiveLookahead)
                })
                .choice(|state| {
                    parse_Whitespace(state, &mut *global)
                        .and_then(|ParseOk { state, .. }| parse_CharacterRange(state, &mut *global))
                        .map_inner(Parsed__override::CharacterRange)
                })
                .choice(|state| {
                    parse_Whitespace(state, &mut *global)
                        .and_then(|ParseOk { state, .. }| parse_StringLiteral(state, &mut *global))
                        .map_inner(Parsed__override::StringLiteral)
                })
                .choice(|state| {
                    parse_Whitespace(state, &mut *global)
                        .and_then(|ParseOk { state, .. }| parse_EndOfInput(state, &mut *global))
                        .map_inner(Parsed__override::EndOfInput)
                })
                .choice(|state| {
                    parse_Whitespace(state, &mut *global)
                        .and_then(|ParseOk { state, .. }| parse_IncludeRule(state, &mut *global))
                        .map_inner(Parsed__override::IncludeRule)
                })
                .choice(|state| {
                    parse_Whitespace(state, &mut *global)
                        .and_then(|ParseOk { state, .. }| parse_Field(state, &mut *global))
                        .map_inner(Parsed__override::Field)
                })
                .end()
        }
        pub type Parsed = Parsed__override;
        use super::DelimitedExpression as Parsed__override;
    }
    #[inline]
    pub(super) fn parse_DelimitedExpression<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, DelimitedExpression> {
        global
            .tracer
            .print_trace_start(&state, "DelimitedExpression");
        let result = (|| {
            let result = DelimitedExpression_impl::parse(state, global)?;
            Ok(result)
        })();
        global.tracer.print_trace_result(&result);
        result
    }
    mod Identifier_impl {
        use super::*;
        mod closure {
            use super::*;
        }
        #[inline(always)]
        pub fn parse<'a, TT: ParseTracer>(
            state: ParseState<'a>,
            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
        ) -> ParseResult<'a, Parsed> {
            let mut iterations: usize = 0;
            let mut state = state;
            loop {
                match parse_IdentifierChar(state.clone(), &mut *global).discard_result() {
                    Ok(ParseOk {
                        result: __result,
                        state: new_state,
                        ..
                    }) => {
                        state = new_state;
                    }
                    Err(err) => {
                        state = state.record_error(err);
                        break;
                    }
                }
                iterations += 1;
            }
            if iterations == 0 {
                return Err(state.report_farthest_error());
            }
            Ok(ParseOk { result: (), state })
        }
        pub type Parsed = ();
    }
    #[inline]
    pub(super) fn parse_Identifier<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, Identifier> {
        global.tracer.print_trace_start(&state, "Identifier");
        let result = (|| {
            let result =
                Identifier_impl::parse(state.clone(), global)?.map_with_state(|_, new_state| {
                    let string = state.slice_until(new_state).to_string();
                    string
                });
            Ok(result)
        })();
        global.tracer.print_trace_result(&result);
        result
    }
    #[inline]
    pub(super) fn parse_IdentifierChar<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, IdentifierChar> {
        if let Ok(result) = parse_character_range(state.clone(), 'a', 'z') {
            return Ok(result);
        }
        if let Ok(result) = parse_character_range(state.clone(), 'A', 'Z') {
            return Ok(result);
        }
        if let Ok(result) = parse_character_range(state.clone(), '0', '9') {
            return Ok(result);
        }
        if let Ok(result) = parse_character_literal(state.clone(), '_') {
            return Ok(result);
        }
        Err(
            state.report_error(ParseErrorSpecifics::ExpectedCharacterClass {
                name: "IdentifierChar",
            }),
        )
    }
    mod StringItem_impl {
        use super::*;
        mod choice_0 {
            use super::*;
            #[inline(always)]
            pub fn parse<'a, TT: ParseTracer>(
                state: ParseState<'a>,
                global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
            ) -> ParseResult<'a, Parsed> {
                let ParseOk { state, .. } =
                    parse_character_literal(state, '\\').discard_result()?;
                let ParseOk {
                    result: _override,
                    state,
                } = ChoiceHelper::new(state)
                    .choice(|state| {
                        parse_SimpleEscape(state, &mut *global)
                            .map_inner(Parsed__override::SimpleEscape)
                    })
                    .choice(|state| {
                        parse_HexaEscape(state, &mut *global)
                            .map_inner(Parsed__override::HexaEscape)
                    })
                    .choice(|state| {
                        parse_Utf8Escape(state, &mut *global)
                            .map_inner(Parsed__override::Utf8Escape)
                    })
                    .end()?;
                Ok(ParseOk {
                    result: _override,
                    state,
                })
            }
            pub type Parsed = Parsed__override;
        }
        mod choice_1 {
            use super::*;
            mod part_0 {
                use super::*;
                mod negative_lookahead {
                    use super::*;
                    #[inline(always)]
                    pub fn parse<'a, TT: ParseTracer>(
                        state: ParseState<'a>,
                        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
                    ) -> ParseResult<'a, Parsed> {
                        parse_character_literal(state, '\\').discard_result()
                    }
                    pub type Parsed = ();
                }
                #[inline(always)]
                pub fn parse<'a, TT: ParseTracer>(
                    state: ParseState<'a>,
                    global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
                ) -> ParseResult<'a, Parsed> {
                    match negative_lookahead::parse(state.clone(), global) {
                        Ok(_) => {
                            Err(state.report_error(ParseErrorSpecifics::NegativeLookaheadFailed))
                        }
                        Err(_) => Ok(ParseOk { result: (), state }),
                    }
                }
                pub type Parsed = ();
            }
            #[inline(always)]
            pub fn parse<'a, TT: ParseTracer>(
                state: ParseState<'a>,
                global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
            ) -> ParseResult<'a, Parsed> {
                let ParseOk { state, .. } = part_0::parse(state, global)?;
                let ParseOk {
                    result: _override,
                    state,
                } = parse_char(state, &mut *global).map_inner(Parsed__override::char)?;
                Ok(ParseOk {
                    result: _override,
                    state,
                })
            }
            pub type Parsed = Parsed__override;
        }
        #[inline(always)]
        pub fn parse<'a, TT: ParseTracer>(
            state: ParseState<'a>,
            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
        ) -> ParseResult<'a, Parsed> {
            ChoiceHelper::new(state)
                .choice(|state| choice_0::parse(state, global))
                .choice(|state| choice_1::parse(state, global))
                .end()
        }
        pub type Parsed = Parsed__override;
        use super::StringItem as Parsed__override;
    }
    #[inline]
    pub(super) fn parse_StringItem<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, StringItem> {
        global.tracer.print_trace_start(&state, "StringItem");
        let result = (|| {
            let result = StringItem_impl::parse(state, global)?;
            Ok(result)
        })();
        global.tracer.print_trace_result(&result);
        result
    }
    mod SimpleEscape_impl {
        use super::*;
        #[inline(always)]
        pub fn parse<'a, TT: ParseTracer>(
            state: ParseState<'a>,
            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
        ) -> ParseResult<'a, Parsed> {
            ChoiceHelper::new(state)
                .choice(|state| {
                    parse_SimpleEscapeNewline(state, &mut *global)
                        .map_inner(Parsed__override::SimpleEscapeNewline)
                })
                .choice(|state| {
                    parse_SimpleEscapeCarriageReturn(state, &mut *global)
                        .map_inner(Parsed__override::SimpleEscapeCarriageReturn)
                })
                .choice(|state| {
                    parse_SimpleEscapeTab(state, &mut *global)
                        .map_inner(Parsed__override::SimpleEscapeTab)
                })
                .choice(|state| {
                    parse_SimpleEscapeBackslash(state, &mut *global)
                        .map_inner(Parsed__override::SimpleEscapeBackslash)
                })
                .choice(|state| {
                    parse_SimpleEscapeQuote(state, &mut *global)
                        .map_inner(Parsed__override::SimpleEscapeQuote)
                })
                .choice(|state| {
                    parse_SimpleEscapeDQuote(state, &mut *global)
                        .map_inner(Parsed__override::SimpleEscapeDQuote)
                })
                .end()
        }
        pub type Parsed = Parsed__override;
        use super::SimpleEscape as Parsed__override;
    }
    #[inline]
    pub(super) fn parse_SimpleEscape<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, SimpleEscape> {
        global.tracer.print_trace_start(&state, "SimpleEscape");
        let result = (|| {
            let result = SimpleEscape_impl::parse(state, global)?;
            Ok(result)
        })();
        global.tracer.print_trace_result(&result);
        result
    }
    mod SimpleEscapeNewline_impl {
        use super::*;
        #[inline(always)]
        pub fn parse<'a, TT: ParseTracer>(
            state: ParseState<'a>,
            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
        ) -> ParseResult<'a, Parsed> {
            parse_character_literal(state, 'n').discard_result()
        }
        pub type Parsed = ();
    }
    #[inline]
    pub(super) fn parse_SimpleEscapeNewline<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, SimpleEscapeNewline> {
        global
            .tracer
            .print_trace_start(&state, "SimpleEscapeNewline");
        let result = (|| {
            let result = SimpleEscapeNewline_impl::parse(state, global)?
                .map(|r| super::SimpleEscapeNewline {});
            Ok(result)
        })();
        global.tracer.print_trace_result(&result);
        result
    }
    mod SimpleEscapeCarriageReturn_impl {
        use super::*;
        #[inline(always)]
        pub fn parse<'a, TT: ParseTracer>(
            state: ParseState<'a>,
            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
        ) -> ParseResult<'a, Parsed> {
            parse_character_literal(state, 'r').discard_result()
        }
        pub type Parsed = ();
    }
    #[inline]
    pub(super) fn parse_SimpleEscapeCarriageReturn<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, SimpleEscapeCarriageReturn> {
        global
            .tracer
            .print_trace_start(&state, "SimpleEscapeCarriageReturn");
        let result = (|| {
            let result = SimpleEscapeCarriageReturn_impl::parse(state, global)?
                .map(|r| super::SimpleEscapeCarriageReturn {});
            Ok(result)
        })();
        global.tracer.print_trace_result(&result);
        result
    }
    mod SimpleEscapeTab_impl {
        use super::*;
        #[inline(always)]
        pub fn parse<'a, TT: ParseTracer>(
            state: ParseState<'a>,
            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
        ) -> ParseResult<'a, Parsed> {
            parse_character_literal(state, 't').discard_result()
        }
        pub type Parsed = ();
    }
    #[inline]
    pub(super) fn parse_SimpleEscapeTab<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, SimpleEscapeTab> {
        global.tracer.print_trace_start(&state, "SimpleEscapeTab");
        let result = (|| {
            let result =
                SimpleEscapeTab_impl::parse(state, global)?.map(|r| super::SimpleEscapeTab {});
            Ok(result)
        })();
        global.tracer.print_trace_result(&result);
        result
    }
    mod SimpleEscapeBackslash_impl {
        use super::*;
        #[inline(always)]
        pub fn parse<'a, TT: ParseTracer>(
            state: ParseState<'a>,
            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
        ) -> ParseResult<'a, Parsed> {
            parse_character_literal(state, '\\').discard_result()
        }
        pub type Parsed = ();
    }
    #[inline]
    pub(super) fn parse_SimpleEscapeBackslash<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, SimpleEscapeBackslash> {
        global
            .tracer
            .print_trace_start(&state, "SimpleEscapeBackslash");
        let result = (|| {
            let result = SimpleEscapeBackslash_impl::parse(state, global)?
                .map(|r| super::SimpleEscapeBackslash {});
            Ok(result)
        })();
        global.tracer.print_trace_result(&result);
        result
    }
    mod SimpleEscapeQuote_impl {
        use super::*;
        #[inline(always)]
        pub fn parse<'a, TT: ParseTracer>(
            state: ParseState<'a>,
            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
        ) -> ParseResult<'a, Parsed> {
            parse_character_literal(state, '\'').discard_result()
        }
        pub type Parsed = ();
    }
    #[inline]
    pub(super) fn parse_SimpleEscapeQuote<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, SimpleEscapeQuote> {
        global.tracer.print_trace_start(&state, "SimpleEscapeQuote");
        let result = (|| {
            let result =
                SimpleEscapeQuote_impl::parse(state, global)?.map(|r| super::SimpleEscapeQuote {});
            Ok(result)
        })();
        global.tracer.print_trace_result(&result);
        result
    }
    mod SimpleEscapeDQuote_impl {
        use super::*;
        #[inline(always)]
        pub fn parse<'a, TT: ParseTracer>(
            state: ParseState<'a>,
            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
        ) -> ParseResult<'a, Parsed> {
            parse_character_literal(state, '"').discard_result()
        }
        pub type Parsed = ();
    }
    #[inline]
    pub(super) fn parse_SimpleEscapeDQuote<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, SimpleEscapeDQuote> {
        global
            .tracer
            .print_trace_start(&state, "SimpleEscapeDQuote");
        let result = (|| {
            let result = SimpleEscapeDQuote_impl::parse(state, global)?
                .map(|r| super::SimpleEscapeDQuote {});
            Ok(result)
        })();
        global.tracer.print_trace_result(&result);
        result
    }
    mod HexaEscape_impl {
        use super::*;
        #[inline(always)]
        pub fn parse<'a, TT: ParseTracer>(
            state: ParseState<'a>,
            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
        ) -> ParseResult<'a, Parsed> {
            let ParseOk { state, .. } = parse_character_literal(state, 'x').discard_result()?;
            let ParseOk { result: c1, state } = parse_HexChar(state, &mut *global)?;
            let ParseOk { result: c2, state } = parse_HexChar(state, &mut *global)?;
            Ok(ParseOk {
                result: Parsed { c1, c2 },
                state,
            })
        }
        pub struct Parsed {
            pub c1: HexChar,
            pub c2: HexChar,
        }
    }
    #[inline]
    pub(super) fn parse_HexaEscape<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, HexaEscape> {
        global.tracer.print_trace_start(&state, "HexaEscape");
        let result = (|| {
            let result = HexaEscape_impl::parse(state, global)?
                .map(|r| super::HexaEscape { c1: r.c1, c2: r.c2 });
            Ok(result)
        })();
        global.tracer.print_trace_result(&result);
        result
    }
    #[inline]
    pub(super) fn parse_HexChar<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, HexChar> {
        if let Ok(result) = parse_character_range(state.clone(), '0', '9') {
            return Ok(result);
        }
        if let Ok(result) = parse_character_range(state.clone(), 'a', 'f') {
            return Ok(result);
        }
        if let Ok(result) = parse_character_range(state.clone(), 'A', 'F') {
            return Ok(result);
        }
        Err(state.report_error(ParseErrorSpecifics::ExpectedCharacterClass { name: "HexChar" }))
    }
    mod Utf8Escape_impl {
        use super::*;
        mod choice_0 {
            use super::*;
            mod part_3 {
                use super::*;
                mod optional {
                    use super::*;
                    mod part_1 {
                        use super::*;
                        mod optional {
                            use super::*;
                            mod part_1 {
                                use super::*;
                                mod optional {
                                    use super::*;
                                    mod part_1 {
                                        use super::*;
                                        mod optional {
                                            use super::*;
                                            #[inline(always)]
                                            pub fn parse<'a, TT: ParseTracer>(
                                                state: ParseState<'a>,
                                                global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
                                            ) -> ParseResult<'a, Parsed>
                                            {
                                                let ParseOk { result: c5, state } =
                                                    parse_HexChar(state, &mut *global)
                                                        .map_inner(Some)?;
                                                let ParseOk { result: c6, state } =
                                                    parse_HexChar(state.clone(), &mut *global)
                                                        .map_inner(Some)
                                                        .or_else(|err| {
                                                            Ok(ParseOk {
                                                                result: Default::default(),
                                                                state: state.record_error(err),
                                                            })
                                                        })?;
                                                Ok(ParseOk {
                                                    result: Parsed { c5, c6 },
                                                    state,
                                                })
                                            }
                                            pub struct Parsed {
                                                pub c5: Option<HexChar>,
                                                pub c6: Option<HexChar>,
                                            }
                                        }
                                        #[inline(always)]
                                        pub fn parse<'a, TT: ParseTracer>(
                                            state: ParseState<'a>,
                                            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
                                        ) -> ParseResult<'a, Parsed>
                                        {
                                            optional::parse(state.clone(), global)
                                                .map_inner(|result| Parsed {
                                                    c5: result.c5,
                                                    c6: result.c6,
                                                })
                                                .or_else(|err| {
                                                    Ok(ParseOk {
                                                        result: Parsed {
                                                            c5: Default::default(),
                                                            c6: Default::default(),
                                                        },
                                                        state: state.record_error(err),
                                                    })
                                                })
                                        }
                                        pub struct Parsed {
                                            pub c5: Option<HexChar>,
                                            pub c6: Option<HexChar>,
                                        }
                                    }
                                    #[inline(always)]
                                    pub fn parse<'a, TT: ParseTracer>(
                                        state: ParseState<'a>,
                                        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
                                    ) -> ParseResult<'a, Parsed>
                                    {
                                        let ParseOk { result: c4, state } =
                                            parse_HexChar(state, &mut *global).map_inner(Some)?;
                                        let ParseOk {
                                            result: part_1::Parsed { c5, c6 },
                                            state,
                                        } = part_1::parse(state, global)?;
                                        Ok(ParseOk {
                                            result: Parsed { c4, c5, c6 },
                                            state,
                                        })
                                    }
                                    pub struct Parsed {
                                        pub c4: Option<HexChar>,
                                        pub c5: Option<HexChar>,
                                        pub c6: Option<HexChar>,
                                    }
                                }
                                #[inline(always)]
                                pub fn parse<'a, TT: ParseTracer>(
                                    state: ParseState<'a>,
                                    global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
                                ) -> ParseResult<'a, Parsed> {
                                    optional::parse(state.clone(), global)
                                        .map_inner(|result| Parsed {
                                            c4: result.c4,
                                            c5: result.c5,
                                            c6: result.c6,
                                        })
                                        .or_else(|err| {
                                            Ok(ParseOk {
                                                result: Parsed {
                                                    c4: Default::default(),
                                                    c5: Default::default(),
                                                    c6: Default::default(),
                                                },
                                                state: state.record_error(err),
                                            })
                                        })
                                }
                                pub struct Parsed {
                                    pub c4: Option<HexChar>,
                                    pub c5: Option<HexChar>,
                                    pub c6: Option<HexChar>,
                                }
                            }
                            #[inline(always)]
                            pub fn parse<'a, TT: ParseTracer>(
                                state: ParseState<'a>,
                                global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
                            ) -> ParseResult<'a, Parsed> {
                                let ParseOk { result: c3, state } =
                                    parse_HexChar(state, &mut *global).map_inner(Some)?;
                                let ParseOk {
                                    result: part_1::Parsed { c4, c5, c6 },
                                    state,
                                } = part_1::parse(state, global)?;
                                Ok(ParseOk {
                                    result: Parsed { c3, c4, c5, c6 },
                                    state,
                                })
                            }
                            pub struct Parsed {
                                pub c3: Option<HexChar>,
                                pub c4: Option<HexChar>,
                                pub c5: Option<HexChar>,
                                pub c6: Option<HexChar>,
                            }
                        }
                        #[inline(always)]
                        pub fn parse<'a, TT: ParseTracer>(
                            state: ParseState<'a>,
                            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
                        ) -> ParseResult<'a, Parsed> {
                            optional::parse(state.clone(), global)
                                .map_inner(|result| Parsed {
                                    c3: result.c3,
                                    c4: result.c4,
                                    c5: result.c5,
                                    c6: result.c6,
                                })
                                .or_else(|err| {
                                    Ok(ParseOk {
                                        result: Parsed {
                                            c3: Default::default(),
                                            c4: Default::default(),
                                            c5: Default::default(),
                                            c6: Default::default(),
                                        },
                                        state: state.record_error(err),
                                    })
                                })
                        }
                        pub struct Parsed {
                            pub c3: Option<HexChar>,
                            pub c4: Option<HexChar>,
                            pub c5: Option<HexChar>,
                            pub c6: Option<HexChar>,
                        }
                    }
                    #[inline(always)]
                    pub fn parse<'a, TT: ParseTracer>(
                        state: ParseState<'a>,
                        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
                    ) -> ParseResult<'a, Parsed> {
                        let ParseOk { result: c2, state } =
                            parse_HexChar(state, &mut *global).map_inner(Some)?;
                        let ParseOk {
                            result: part_1::Parsed { c3, c4, c5, c6 },
                            state,
                        } = part_1::parse(state, global)?;
                        Ok(ParseOk {
                            result: Parsed { c2, c3, c4, c5, c6 },
                            state,
                        })
                    }
                    pub struct Parsed {
                        pub c2: Option<HexChar>,
                        pub c3: Option<HexChar>,
                        pub c4: Option<HexChar>,
                        pub c5: Option<HexChar>,
                        pub c6: Option<HexChar>,
                    }
                }
                #[inline(always)]
                pub fn parse<'a, TT: ParseTracer>(
                    state: ParseState<'a>,
                    global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
                ) -> ParseResult<'a, Parsed> {
                    optional::parse(state.clone(), global)
                        .map_inner(|result| Parsed {
                            c2: result.c2,
                            c3: result.c3,
                            c4: result.c4,
                            c5: result.c5,
                            c6: result.c6,
                        })
                        .or_else(|err| {
                            Ok(ParseOk {
                                result: Parsed {
                                    c2: Default::default(),
                                    c3: Default::default(),
                                    c4: Default::default(),
                                    c5: Default::default(),
                                    c6: Default::default(),
                                },
                                state: state.record_error(err),
                            })
                        })
                }
                pub struct Parsed {
                    pub c2: Option<HexChar>,
                    pub c3: Option<HexChar>,
                    pub c4: Option<HexChar>,
                    pub c5: Option<HexChar>,
                    pub c6: Option<HexChar>,
                }
            }
            #[inline(always)]
            pub fn parse<'a, TT: ParseTracer>(
                state: ParseState<'a>,
                global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
            ) -> ParseResult<'a, Parsed> {
                let ParseOk { state, .. } = parse_character_literal(state, 'u').discard_result()?;
                let ParseOk { state, .. } = parse_character_literal(state, '{').discard_result()?;
                let ParseOk { result: c1, state } = parse_HexChar(state, &mut *global)?;
                let ParseOk {
                    result: part_3::Parsed { c2, c3, c4, c5, c6 },
                    state,
                } = part_3::parse(state, global)?;
                let ParseOk { state, .. } = parse_character_literal(state, '}').discard_result()?;
                Ok(ParseOk {
                    result: Parsed {
                        c1,
                        c2,
                        c3,
                        c4,
                        c5,
                        c6,
                    },
                    state,
                })
            }
            pub struct Parsed {
                pub c1: HexChar,
                pub c2: Option<HexChar>,
                pub c3: Option<HexChar>,
                pub c4: Option<HexChar>,
                pub c5: Option<HexChar>,
                pub c6: Option<HexChar>,
            }
        }
        mod choice_1 {
            use super::*;
            #[inline(always)]
            pub fn parse<'a, TT: ParseTracer>(
                state: ParseState<'a>,
                global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
            ) -> ParseResult<'a, Parsed> {
                let ParseOk { state, .. } = parse_character_literal(state, 'u').discard_result()?;
                let ParseOk { result: c1, state } = parse_HexChar(state, &mut *global)?;
                let ParseOk { result: c2, state } =
                    parse_HexChar(state, &mut *global).map_inner(Some)?;
                let ParseOk { result: c3, state } =
                    parse_HexChar(state, &mut *global).map_inner(Some)?;
                let ParseOk { result: c4, state } =
                    parse_HexChar(state, &mut *global).map_inner(Some)?;
                Ok(ParseOk {
                    result: Parsed { c1, c2, c3, c4 },
                    state,
                })
            }
            pub struct Parsed {
                pub c1: HexChar,
                pub c2: Option<HexChar>,
                pub c3: Option<HexChar>,
                pub c4: Option<HexChar>,
            }
        }
        mod choice_2 {
            use super::*;
            #[inline(always)]
            pub fn parse<'a, TT: ParseTracer>(
                state: ParseState<'a>,
                global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
            ) -> ParseResult<'a, Parsed> {
                let ParseOk { state, .. } = parse_character_literal(state, 'U').discard_result()?;
                let ParseOk { state, .. } = parse_character_literal(state, '0').discard_result()?;
                let ParseOk { state, .. } = parse_character_literal(state, '0').discard_result()?;
                let ParseOk { result: c1, state } = parse_HexChar(state, &mut *global)?;
                let ParseOk { result: c2, state } =
                    parse_HexChar(state, &mut *global).map_inner(Some)?;
                let ParseOk { result: c3, state } =
                    parse_HexChar(state, &mut *global).map_inner(Some)?;
                let ParseOk { result: c4, state } =
                    parse_HexChar(state, &mut *global).map_inner(Some)?;
                let ParseOk { result: c5, state } =
                    parse_HexChar(state, &mut *global).map_inner(Some)?;
                let ParseOk { result: c6, state } =
                    parse_HexChar(state, &mut *global).map_inner(Some)?;
                Ok(ParseOk {
                    result: Parsed {
                        c1,
                        c2,
                        c3,
                        c4,
                        c5,
                        c6,
                    },
                    state,
                })
            }
            pub struct Parsed {
                pub c1: HexChar,
                pub c2: Option<HexChar>,
                pub c3: Option<HexChar>,
                pub c4: Option<HexChar>,
                pub c5: Option<HexChar>,
                pub c6: Option<HexChar>,
            }
        }
        #[inline(always)]
        pub fn parse<'a, TT: ParseTracer>(
            state: ParseState<'a>,
            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
        ) -> ParseResult<'a, Parsed> {
            ChoiceHelper::new(state)
                .choice(|state| {
                    choice_0::parse(state, global).map_inner(|r| Parsed {
                        c1: r.c1,
                        c2: r.c2,
                        c3: r.c3,
                        c4: r.c4,
                        c5: r.c5,
                        c6: r.c6,
                    })
                })
                .choice(|state| {
                    choice_1::parse(state, global).map_inner(|r| Parsed {
                        c1: r.c1,
                        c2: r.c2,
                        c3: r.c3,
                        c4: r.c4,
                        c5: None,
                        c6: None,
                    })
                })
                .choice(|state| {
                    choice_2::parse(state, global).map_inner(|r| Parsed {
                        c1: r.c1,
                        c2: r.c2,
                        c3: r.c3,
                        c4: r.c4,
                        c5: r.c5,
                        c6: r.c6,
                    })
                })
                .end()
        }
        pub struct Parsed {
            pub c1: HexChar,
            pub c2: Option<HexChar>,
            pub c3: Option<HexChar>,
            pub c4: Option<HexChar>,
            pub c5: Option<HexChar>,
            pub c6: Option<HexChar>,
        }
    }
    #[inline]
    pub(super) fn parse_Utf8Escape<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, Utf8Escape> {
        global.tracer.print_trace_start(&state, "Utf8Escape");
        let result = (|| {
            let result = Utf8Escape_impl::parse(state, global)?.map(|r| super::Utf8Escape {
                c1: r.c1,
                c2: r.c2,
                c3: r.c3,
                c4: r.c4,
                c5: r.c5,
                c6: r.c6,
            });
            Ok(result)
        })();
        global.tracer.print_trace_result(&result);
        result
    }
    mod DirectiveExpression_impl {
        use super::*;
        #[inline(always)]
        pub fn parse<'a, TT: ParseTracer>(
            state: ParseState<'a>,
            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
        ) -> ParseResult<'a, Parsed> {
            ChoiceHelper::new(state)
                .choice(|state| {
                    parse_Whitespace(state, &mut *global)
                        .and_then(|ParseOk { state, .. }| {
                            parse_StringDirective(state, &mut *global)
                        })
                        .map_inner(Parsed__override::StringDirective)
                })
                .choice(|state| {
                    parse_Whitespace(state, &mut *global)
                        .and_then(|ParseOk { state, .. }| {
                            parse_NoSkipWsDirective(state, &mut *global)
                        })
                        .map_inner(Parsed__override::NoSkipWsDirective)
                })
                .choice(|state| {
                    parse_Whitespace(state, &mut *global)
                        .and_then(|ParseOk { state, .. }| {
                            parse_ExportDirective(state, &mut *global)
                        })
                        .map_inner(Parsed__override::ExportDirective)
                })
                .choice(|state| {
                    parse_Whitespace(state, &mut *global)
                        .and_then(|ParseOk { state, .. }| {
                            parse_PositionDirective(state, &mut *global)
                        })
                        .map_inner(Parsed__override::PositionDirective)
                })
                .choice(|state| {
                    parse_Whitespace(state, &mut *global)
                        .and_then(|ParseOk { state, .. }| {
                            parse_MemoizeDirective(state, &mut *global)
                        })
                        .map_inner(Parsed__override::MemoizeDirective)
                })
                .choice(|state| {
                    parse_Whitespace(state, &mut *global)
                        .and_then(|ParseOk { state, .. }| {
                            parse_LeftrecDirective(state, &mut *global)
                        })
                        .map_inner(Parsed__override::LeftrecDirective)
                })
                .choice(|state| {
                    parse_Whitespace(state, &mut *global)
                        .and_then(|ParseOk { state, .. }| parse_CheckDirective(state, &mut *global))
                        .map_inner(Parsed__override::CheckDirective)
                })
                .end()
        }
        pub type Parsed = Parsed__override;
        use super::DirectiveExpression as Parsed__override;
    }
    #[inline]
    pub(super) fn parse_DirectiveExpression<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, DirectiveExpression> {
        global
            .tracer
            .print_trace_start(&state, "DirectiveExpression");
        let result = (|| {
            let result = DirectiveExpression_impl::parse(state, global)?;
            Ok(result)
        })();
        global.tracer.print_trace_result(&result);
        result
    }
    mod StringDirective_impl {
        use super::*;
        #[inline(always)]
        pub fn parse<'a, TT: ParseTracer>(
            state: ParseState<'a>,
            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
        ) -> ParseResult<'a, Parsed> {
            parse_Whitespace(state, &mut *global)
                .and_then(|ParseOk { state, .. }| parse_string_literal(state, "@string"))
                .discard_result()
        }
        pub type Parsed = ();
    }
    #[inline]
    pub(super) fn parse_StringDirective<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, StringDirective> {
        global.tracer.print_trace_start(&state, "StringDirective");
        let result = (|| {
            let result =
                StringDirective_impl::parse(state, global)?.map(|r| super::StringDirective {});
            Ok(result)
        })();
        global.tracer.print_trace_result(&result);
        result
    }
    mod CharDirective_impl {
        use super::*;
        #[inline(always)]
        pub fn parse<'a, TT: ParseTracer>(
            state: ParseState<'a>,
            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
        ) -> ParseResult<'a, Parsed> {
            parse_Whitespace(state, &mut *global)
                .and_then(|ParseOk { state, .. }| parse_string_literal(state, "@char"))
                .discard_result()
        }
        pub type Parsed = ();
    }
    #[inline]
    pub(super) fn parse_CharDirective<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, CharDirective> {
        global.tracer.print_trace_start(&state, "CharDirective");
        let result = (|| {
            let result = CharDirective_impl::parse(state, global)?.map(|r| super::CharDirective {});
            Ok(result)
        })();
        global.tracer.print_trace_result(&result);
        result
    }
    mod NoSkipWsDirective_impl {
        use super::*;
        #[inline(always)]
        pub fn parse<'a, TT: ParseTracer>(
            state: ParseState<'a>,
            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
        ) -> ParseResult<'a, Parsed> {
            parse_Whitespace(state, &mut *global)
                .and_then(|ParseOk { state, .. }| parse_string_literal(state, "@no_skip_ws"))
                .discard_result()
        }
        pub type Parsed = ();
    }
    #[inline]
    pub(super) fn parse_NoSkipWsDirective<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, NoSkipWsDirective> {
        global.tracer.print_trace_start(&state, "NoSkipWsDirective");
        let result = (|| {
            let result =
                NoSkipWsDirective_impl::parse(state, global)?.map(|r| super::NoSkipWsDirective {});
            Ok(result)
        })();
        global.tracer.print_trace_result(&result);
        result
    }
    mod ExportDirective_impl {
        use super::*;
        #[inline(always)]
        pub fn parse<'a, TT: ParseTracer>(
            state: ParseState<'a>,
            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
        ) -> ParseResult<'a, Parsed> {
            parse_Whitespace(state, &mut *global)
                .and_then(|ParseOk { state, .. }| parse_string_literal(state, "@export"))
                .discard_result()
        }
        pub type Parsed = ();
    }
    #[inline]
    pub(super) fn parse_ExportDirective<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, ExportDirective> {
        global.tracer.print_trace_start(&state, "ExportDirective");
        let result = (|| {
            let result =
                ExportDirective_impl::parse(state, global)?.map(|r| super::ExportDirective {});
            Ok(result)
        })();
        global.tracer.print_trace_result(&result);
        result
    }
    mod PositionDirective_impl {
        use super::*;
        #[inline(always)]
        pub fn parse<'a, TT: ParseTracer>(
            state: ParseState<'a>,
            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
        ) -> ParseResult<'a, Parsed> {
            parse_Whitespace(state, &mut *global)
                .and_then(|ParseOk { state, .. }| parse_string_literal(state, "@position"))
                .discard_result()
        }
        pub type Parsed = ();
    }
    #[inline]
    pub(super) fn parse_PositionDirective<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, PositionDirective> {
        global.tracer.print_trace_start(&state, "PositionDirective");
        let result = (|| {
            let result =
                PositionDirective_impl::parse(state, global)?.map(|r| super::PositionDirective {});
            Ok(result)
        })();
        global.tracer.print_trace_result(&result);
        result
    }
    mod MemoizeDirective_impl {
        use super::*;
        #[inline(always)]
        pub fn parse<'a, TT: ParseTracer>(
            state: ParseState<'a>,
            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
        ) -> ParseResult<'a, Parsed> {
            parse_Whitespace(state, &mut *global)
                .and_then(|ParseOk { state, .. }| parse_string_literal(state, "@memoize"))
                .discard_result()
        }
        pub type Parsed = ();
    }
    #[inline]
    pub(super) fn parse_MemoizeDirective<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, MemoizeDirective> {
        global.tracer.print_trace_start(&state, "MemoizeDirective");
        let result = (|| {
            let result =
                MemoizeDirective_impl::parse(state, global)?.map(|r| super::MemoizeDirective {});
            Ok(result)
        })();
        global.tracer.print_trace_result(&result);
        result
    }
    mod LeftrecDirective_impl {
        use super::*;
        #[inline(always)]
        pub fn parse<'a, TT: ParseTracer>(
            state: ParseState<'a>,
            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
        ) -> ParseResult<'a, Parsed> {
            parse_Whitespace(state, &mut *global)
                .and_then(|ParseOk { state, .. }| parse_string_literal(state, "@leftrec"))
                .discard_result()
        }
        pub type Parsed = ();
    }
    #[inline]
    pub(super) fn parse_LeftrecDirective<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, LeftrecDirective> {
        global.tracer.print_trace_start(&state, "LeftrecDirective");
        let result = (|| {
            let result =
                LeftrecDirective_impl::parse(state, global)?.map(|r| super::LeftrecDirective {});
            Ok(result)
        })();
        global.tracer.print_trace_result(&result);
        result
    }
    mod CheckDirective_impl {
        use super::*;
        #[inline(always)]
        pub fn parse<'a, TT: ParseTracer>(
            state: ParseState<'a>,
            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
        ) -> ParseResult<'a, Parsed> {
            let ParseOk { state, .. } = parse_Whitespace(state, &mut *global)
                .and_then(|ParseOk { state, .. }| parse_string_literal(state, "@check"))
                .discard_result()?;
            let ParseOk { state, .. } = parse_Whitespace(state, &mut *global)
                .and_then(|ParseOk { state, .. }| parse_character_literal(state, '('))
                .discard_result()?;
            let ParseOk {
                result: function,
                state,
            } = parse_Whitespace(state, &mut *global)
                .and_then(|ParseOk { state, .. }| parse_NamespacedRustName(state, &mut *global))?;
            let ParseOk { state, .. } = parse_Whitespace(state, &mut *global)
                .and_then(|ParseOk { state, .. }| parse_character_literal(state, ')'))
                .discard_result()?;
            Ok(ParseOk {
                result: function,
                state,
            })
        }
        pub type Parsed = NamespacedRustName;
    }
    #[inline]
    pub(super) fn parse_CheckDirective<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, CheckDirective> {
        global.tracer.print_trace_start(&state, "CheckDirective");
        let result = (|| {
            let result = CheckDirective_impl::parse(state, global)?
                .map(|r| super::CheckDirective { function: r });
            Ok(result)
        })();
        global.tracer.print_trace_result(&result);
        result
    }
    mod ExternDirective_impl {
        use super::*;
        mod part_3 {
            use super::*;
            mod optional {
                use super::*;
                #[inline(always)]
                pub fn parse<'a, TT: ParseTracer>(
                    state: ParseState<'a>,
                    global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
                ) -> ParseResult<'a, Parsed> {
                    let ParseOk { state, .. } = parse_Whitespace(state, &mut *global)
                        .and_then(|ParseOk { state, .. }| parse_string_literal(state, "->"))
                        .discard_result()?;
                    let ParseOk {
                        result: return_type,
                        state,
                    } = parse_Whitespace(state, &mut *global)
                        .and_then(|ParseOk { state, .. }| {
                            parse_NamespacedRustName(state, &mut *global)
                        })
                        .map_inner(Some)?;
                    Ok(ParseOk {
                        result: return_type,
                        state,
                    })
                }
                pub type Parsed = Option<NamespacedRustName>;
            }
            #[inline(always)]
            pub fn parse<'a, TT: ParseTracer>(
                state: ParseState<'a>,
                global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
            ) -> ParseResult<'a, Parsed> {
                optional::parse(state.clone(), global).or_else(|err| {
                    Ok(ParseOk {
                        result: Default::default(),
                        state: state.record_error(err),
                    })
                })
            }
            pub type Parsed = Option<NamespacedRustName>;
        }
        #[inline(always)]
        pub fn parse<'a, TT: ParseTracer>(
            state: ParseState<'a>,
            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
        ) -> ParseResult<'a, Parsed> {
            let ParseOk { state, .. } = parse_Whitespace(state, &mut *global)
                .and_then(|ParseOk { state, .. }| parse_string_literal(state, "@extern"))
                .discard_result()?;
            let ParseOk { state, .. } = parse_Whitespace(state, &mut *global)
                .and_then(|ParseOk { state, .. }| parse_character_literal(state, '('))
                .discard_result()?;
            let ParseOk {
                result: function,
                state,
            } = parse_Whitespace(state, &mut *global)
                .and_then(|ParseOk { state, .. }| parse_NamespacedRustName(state, &mut *global))?;
            let ParseOk {
                result: return_type,
                state,
            } = part_3::parse(state, global)?;
            let ParseOk { state, .. } = parse_Whitespace(state, &mut *global)
                .and_then(|ParseOk { state, .. }| parse_character_literal(state, ')'))
                .discard_result()?;
            Ok(ParseOk {
                result: Parsed {
                    function,
                    return_type,
                },
                state,
            })
        }
        pub struct Parsed {
            pub function: NamespacedRustName,
            pub return_type: Option<NamespacedRustName>,
        }
    }
    #[inline]
    pub(super) fn parse_ExternDirective<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, ExternDirective> {
        global.tracer.print_trace_start(&state, "ExternDirective");
        let result = (|| {
            let result =
                ExternDirective_impl::parse(state, global)?.map(|r| super::ExternDirective {
                    function: r.function,
                    return_type: r.return_type,
                });
            Ok(result)
        })();
        global.tracer.print_trace_result(&result);
        result
    }
    mod NamespacedRustName_impl {
        use super::*;
        mod part_1 {
            use super::*;
            mod closure {
                use super::*;
                #[inline(always)]
                pub fn parse<'a, TT: ParseTracer>(
                    state: ParseState<'a>,
                    global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
                ) -> ParseResult<'a, Parsed> {
                    let ParseOk { state, .. } = parse_Whitespace(state, &mut *global)
                        .and_then(|ParseOk { state, .. }| parse_string_literal(state, "::"))
                        .discard_result()?;
                    let ParseOk {
                        result: mut _override,
                        state,
                    } = parse_Whitespace(state, &mut *global)
                        .and_then(|ParseOk { state, .. }| parse_RustNamePart(state, &mut *global))
                        .map_inner(|result| vec![result])?;
                    Ok(ParseOk {
                        result: _override,
                        state,
                    })
                }
                pub type Parsed = Vec<RustNamePart>;
            }
            #[inline(always)]
            pub fn parse<'a, TT: ParseTracer>(
                state: ParseState<'a>,
                global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
            ) -> ParseResult<'a, Parsed> {
                let mut iterations: usize = 0;
                let mut state = state;
                let mut _override: Vec<RustNamePart> = Vec::new();
                loop {
                    match closure::parse(state.clone(), global) {
                        Ok(ParseOk {
                            result: __result,
                            state: new_state,
                            ..
                        }) => {
                            _override.extend(__result);
                            state = new_state;
                        }
                        Err(err) => {
                            state = state.record_error(err);
                            break;
                        }
                    }
                    iterations += 1;
                }
                Ok(ParseOk {
                    result: _override,
                    state,
                })
            }
            pub type Parsed = Vec<RustNamePart>;
        }
        #[inline(always)]
        pub fn parse<'a, TT: ParseTracer>(
            state: ParseState<'a>,
            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
        ) -> ParseResult<'a, Parsed> {
            let ParseOk {
                result: mut _override,
                state,
            } = parse_Whitespace(state, &mut *global)
                .and_then(|ParseOk { state, .. }| parse_RustNamePart(state, &mut *global))
                .map_inner(|result| vec![result])?;
            let ParseOk {
                result: extend__override_with,
                state,
            } = part_1::parse(state, global)?;
            _override.extend(extend__override_with);
            Ok(ParseOk {
                result: _override,
                state,
            })
        }
        pub type Parsed = Vec<RustNamePart>;
        use super::NamespacedRustName as Parsed__override;
    }
    #[inline]
    pub(super) fn parse_NamespacedRustName<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, NamespacedRustName> {
        global
            .tracer
            .print_trace_start(&state, "NamespacedRustName");
        let result = (|| {
            let result = NamespacedRustName_impl::parse(state, global)?;
            Ok(result)
        })();
        global.tracer.print_trace_result(&result);
        result
    }
    mod RustNamePart_impl {
        use super::*;
        mod closure {
            use super::*;
            mod part_0 {
                use super::*;
                mod negative_lookahead {
                    use super::*;
                    #[inline(always)]
                    pub fn parse<'a, TT: ParseTracer>(
                        state: ParseState<'a>,
                        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
                    ) -> ParseResult<'a, Parsed> {
                        ChoiceHelper::new(state)
                            .choice(|state| {
                                parse_Whitespace(state, &mut *global)
                                    .and_then(|ParseOk { state, .. }| {
                                        parse_character_literal(state, '-')
                                    })
                                    .discard_result()
                            })
                            .choice(|state| {
                                parse_Whitespace(state, &mut *global)
                                    .and_then(|ParseOk { state, .. }| {
                                        parse_character_literal(state, ')')
                                    })
                                    .discard_result()
                            })
                            .choice(|state| {
                                parse_Whitespace(state, &mut *global)
                                    .and_then(|ParseOk { state, .. }| {
                                        parse_character_literal(state, ':')
                                    })
                                    .discard_result()
                            })
                            .end()
                    }
                    pub type Parsed = ();
                }
                #[inline(always)]
                pub fn parse<'a, TT: ParseTracer>(
                    state: ParseState<'a>,
                    global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
                ) -> ParseResult<'a, Parsed> {
                    match negative_lookahead::parse(state.clone(), global) {
                        Ok(_) => {
                            Err(state.report_error(ParseErrorSpecifics::NegativeLookaheadFailed))
                        }
                        Err(_) => Ok(ParseOk { result: (), state }),
                    }
                }
                pub type Parsed = ();
            }
            #[inline(always)]
            pub fn parse<'a, TT: ParseTracer>(
                state: ParseState<'a>,
                global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
            ) -> ParseResult<'a, Parsed> {
                let ParseOk { state, .. } = part_0::parse(state, global)?;
                let ParseOk { state, .. } = parse_Whitespace(state, &mut *global)
                    .and_then(|ParseOk { state, .. }| parse_char(state, &mut *global))
                    .discard_result()?;
                Ok(ParseOk { result: (), state })
            }
            pub type Parsed = ();
        }
        #[inline(always)]
        pub fn parse<'a, TT: ParseTracer>(
            state: ParseState<'a>,
            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
        ) -> ParseResult<'a, Parsed> {
            let mut iterations: usize = 0;
            let mut state = state;
            loop {
                match closure::parse(state.clone(), global) {
                    Ok(ParseOk {
                        result: __result,
                        state: new_state,
                        ..
                    }) => {
                        state = new_state;
                    }
                    Err(err) => {
                        state = state.record_error(err);
                        break;
                    }
                }
                iterations += 1;
            }
            if iterations == 0 {
                return Err(state.report_farthest_error());
            }
            Ok(ParseOk { result: (), state })
        }
        pub type Parsed = ();
    }
    #[inline]
    pub(super) fn parse_RustNamePart<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, RustNamePart> {
        global.tracer.print_trace_start(&state, "RustNamePart");
        let result = (|| {
            let result =
                RustNamePart_impl::parse(state.clone(), global)?.map_with_state(|_, new_state| {
                    let string = state.slice_until(new_state).to_string();
                    string
                });
            Ok(result)
        })();
        global.tracer.print_trace_result(&result);
        result
    }
    mod EndOfInput_impl {
        use super::*;
        #[inline(always)]
        pub fn parse<'a, TT: ParseTracer>(
            state: ParseState<'a>,
            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
        ) -> ParseResult<'a, Parsed> {
            parse_Whitespace(state, &mut *global)
                .and_then(|ParseOk { state, .. }| parse_character_literal(state, '$'))
                .discard_result()
        }
        pub type Parsed = ();
    }
    #[inline]
    pub(super) fn parse_EndOfInput<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, EndOfInput> {
        global.tracer.print_trace_start(&state, "EndOfInput");
        let result = (|| {
            let result = EndOfInput_impl::parse(state, global)?.map(|r| super::EndOfInput {});
            Ok(result)
        })();
        global.tracer.print_trace_result(&result);
        result
    }
    mod Whitespace_impl {
        use super::*;
        mod closure {
            use super::*;
        }
        #[inline(always)]
        pub fn parse<'a, TT: ParseTracer>(
            state: ParseState<'a>,
            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
        ) -> ParseResult<'a, Parsed> {
            let mut iterations: usize = 0;
            let mut state = state;
            loop {
                match ChoiceHelper::new(state.clone())
                    .choice(|state| parse_Comment(state, &mut *global).discard_result())
                    .choice(|state| parse_character_literal(state, '\t').discard_result())
                    .choice(|state| parse_character_literal(state, '\n').discard_result())
                    .choice(|state| parse_character_literal(state, '\u{c}').discard_result())
                    .choice(|state| parse_character_literal(state, '\r').discard_result())
                    .choice(|state| parse_character_literal(state, ' ').discard_result())
                    .end()
                {
                    Ok(ParseOk {
                        result: __result,
                        state: new_state,
                        ..
                    }) => {
                        state = new_state;
                    }
                    Err(err) => {
                        state = state.record_error(err);
                        break;
                    }
                }
                iterations += 1;
            }
            Ok(ParseOk { result: (), state })
        }
        pub type Parsed = ();
    }
    #[inline]
    pub(super) fn parse_Whitespace<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, Whitespace> {
        global.tracer.print_trace_start(&state, "Whitespace");
        let result = (|| {
            let result = Whitespace_impl::parse(state, global)?.map(|r| super::Whitespace {});
            Ok(result)
        })();
        global.tracer.print_trace_result(&result);
        result
    }
    mod Comment_impl {
        use super::*;
        mod part_1 {
            use super::*;
            mod closure {
                use super::*;
                mod part_0 {
                    use super::*;
                    mod negative_lookahead {
                        use super::*;
                        #[inline(always)]
                        pub fn parse<'a, TT: ParseTracer>(
                            state: ParseState<'a>,
                            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
                        ) -> ParseResult<'a, Parsed> {
                            parse_character_literal(state, '\n').discard_result()
                        }
                        pub type Parsed = ();
                    }
                    #[inline(always)]
                    pub fn parse<'a, TT: ParseTracer>(
                        state: ParseState<'a>,
                        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
                    ) -> ParseResult<'a, Parsed> {
                        match negative_lookahead::parse(state.clone(), global) {
                            Ok(_) => {
                                Err(state
                                    .report_error(ParseErrorSpecifics::NegativeLookaheadFailed))
                            }
                            Err(_) => Ok(ParseOk { result: (), state }),
                        }
                    }
                    pub type Parsed = ();
                }
                #[inline(always)]
                pub fn parse<'a, TT: ParseTracer>(
                    state: ParseState<'a>,
                    global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
                ) -> ParseResult<'a, Parsed> {
                    let ParseOk { state, .. } = part_0::parse(state, global)?;
                    let ParseOk { state, .. } = parse_char(state, &mut *global).discard_result()?;
                    Ok(ParseOk { result: (), state })
                }
                pub type Parsed = ();
            }
            #[inline(always)]
            pub fn parse<'a, TT: ParseTracer>(
                state: ParseState<'a>,
                global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
            ) -> ParseResult<'a, Parsed> {
                let mut iterations: usize = 0;
                let mut state = state;
                loop {
                    match closure::parse(state.clone(), global) {
                        Ok(ParseOk {
                            result: __result,
                            state: new_state,
                            ..
                        }) => {
                            state = new_state;
                        }
                        Err(err) => {
                            state = state.record_error(err);
                            break;
                        }
                    }
                    iterations += 1;
                }
                Ok(ParseOk { result: (), state })
            }
            pub type Parsed = ();
        }
        #[inline(always)]
        pub fn parse<'a, TT: ParseTracer>(
            state: ParseState<'a>,
            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
        ) -> ParseResult<'a, Parsed> {
            let ParseOk { state, .. } = parse_character_literal(state, '#').discard_result()?;
            let ParseOk { state, .. } = part_1::parse(state, global)?;
            let ParseOk { state, .. } = parse_character_literal(state, '\n').discard_result()?;
            Ok(ParseOk { result: (), state })
        }
        pub type Parsed = ();
    }
    #[inline]
    pub(super) fn parse_Comment<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, Comment> {
        global.tracer.print_trace_start(&state, "Comment");
        let result = (|| {
            let result = Comment_impl::parse(state, global)?.map(|r| super::Comment {});
            Ok(result)
        })();
        global.tracer.print_trace_result(&result);
        result
    }
}
