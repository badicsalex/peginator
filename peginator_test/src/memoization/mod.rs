// Copyright (C) 2022, Alex Badics
// This file is part of peginator
// Licensed under the MIT license. See LICENSE file in the project root for details.

mod grammar;
// This file was generated by Peginator v0.2.5@2022-09-26T12:43:24.470553244+00:00
// Hash of the grammar file: 08A9860625C3B9329F9289E357CC15048E3774F3D8D95C34B81A9C327252595F
// Any changes to it will be lost on regeneration

#[derive(Debug, Clone, PartialEq, Eq)]
pub struct Root {
    pub parsed: Recursive,
}
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct Recursive {
    pub inner: Option<Box<Recursive>>,
}
impl peginator_generated::PegParser for Root {
    fn parse_advanced<T: peginator_generated::ParseTracer>(
        s: &str,
        settings: &peginator_generated::ParseSettings,
    ) -> Result<Self, peginator_generated::ParseError> {
        Ok(peginator_generated::parse_Root(
            peginator_generated::ParseState::new(s, settings),
            T::new(),
            &mut Default::default(),
        )?
        .result)
    }
}
#[allow(
    non_snake_case,
    unused_variables,
    unused_imports,
    unused_mut,
    dead_code
)]
mod peginator_generated {
    use super::*;
    use peginator::runtime::*;
    pub use peginator::runtime::{
        IndentedTracer, ParseError, ParseSettings, ParseState, ParseTracer, PegParser, PegPosition,
    };
    #[derive(Default)]
    pub struct ParseCache<'a> {
        pub c_Recursive: CacheEntries<'a, Recursive>,
        _please_dont_complain: std::marker::PhantomData<&'a ()>,
    }
    mod Root_impl {
        use super::*;
        mod part_0 {
            use super::*;
            #[inline(always)]
            pub fn parse<'a>(
                state: ParseState<'a>,
                tracer: impl ParseTracer,
                cache: &mut ParseCache<'a>,
            ) -> ParseResult<'a, Parsed> {
                let ParseOk { state, .. } = parse_Whitespace(state, tracer, cache)?;
                let ok_result = parse_Recursive(state, tracer, cache)?;
                Ok(ok_result.map(|result| Parsed { parsed: result }))
            }
            pub struct Parsed {
                pub parsed: Recursive,
            }
        }
        mod part_1 {
            use super::*;
            #[inline(always)]
            pub fn parse<'a>(
                state: ParseState<'a>,
                tracer: impl ParseTracer,
                cache: &mut ParseCache<'a>,
            ) -> ParseResult<'a, Parsed> {
                let ParseOk { state, .. } = parse_Whitespace(state, tracer, cache)?;
                let ok_result = parse_character_literal(state, '.')?;
                Ok(ok_result.map(|_| Parsed))
            }
            pub struct Parsed;
        }
        mod part_2 {
            use super::*;
            #[inline(always)]
            pub fn parse<'a>(
                state: ParseState<'a>,
                tracer: impl ParseTracer,
                cache: &mut ParseCache<'a>,
            ) -> ParseResult<'a, Parsed> {
                let ParseOk { state, .. } = parse_Whitespace(state, tracer, cache)?;
                if state.is_empty() {
                    Ok(ParseOk {
                        result: Parsed,
                        state,
                        farthest_error: None,
                    })
                } else {
                    Err(state.report_error(ParseErrorSpecifics::ExpectedEoi))
                }
            }
            pub struct Parsed;
        }
        #[inline(always)]
        pub fn parse<'a>(
            state: ParseState<'a>,
            tracer: impl ParseTracer,
            cache: &mut ParseCache<'a>,
        ) -> ParseResult<'a, Parsed> {
            let mut state = state;
            let mut farthest_error: Option<ParseError> = None;
            let result = match part_0::parse(state, tracer, cache) {
                Ok(ParseOk {
                    result,
                    state: new_state,
                    farthest_error: new_farthest_error,
                }) => {
                    farthest_error = combine_errors(farthest_error, new_farthest_error);
                    state = new_state;
                    result
                }
                Err(err) => return Err(combine_errors(farthest_error, Some(err)).unwrap()),
            };
            let parsed = result.parsed;
            match part_1::parse(state, tracer, cache) {
                Ok(ParseOk {
                    result: _,
                    state: new_state,
                    farthest_error: new_farthest_error,
                }) => {
                    farthest_error = combine_errors(farthest_error, new_farthest_error);
                    state = new_state;
                }
                Err(err) => return Err(combine_errors(farthest_error, Some(err)).unwrap()),
            }
            match part_2::parse(state, tracer, cache) {
                Ok(ParseOk {
                    result: _,
                    state: new_state,
                    farthest_error: new_farthest_error,
                }) => {
                    farthest_error = combine_errors(farthest_error, new_farthest_error);
                    state = new_state;
                }
                Err(err) => return Err(combine_errors(farthest_error, Some(err)).unwrap()),
            }
            Ok(ParseOk {
                result: Parsed { parsed },
                state,
                farthest_error,
            })
        }
        pub struct Parsed {
            pub parsed: Recursive,
        }
        #[inline(always)]
        pub fn rule_parser<'a>(
            state: ParseState<'a>,
            tracer: impl ParseTracer,
            cache: &mut ParseCache<'a>,
        ) -> ParseResult<'a, super::Root> {
            let result = parse(state, tracer, cache)?.map(|r| super::Root { parsed: r.parsed });
            Ok(result)
        }
    }
    #[inline]
    pub(super) fn parse_Root<'a>(
        state: ParseState<'a>,
        tracer: impl ParseTracer,
        cache: &mut ParseCache<'a>,
    ) -> ParseResult<'a, Root> {
        tracer.run_traced("Root", state, |state, tracer| {
            Root_impl::rule_parser(state, tracer, cache)
        })
    }
    mod Recursive_impl {
        use super::*;
        mod choice_0 {
            use super::*;
            mod part_0 {
                use super::*;
                #[inline(always)]
                pub fn parse<'a>(
                    state: ParseState<'a>,
                    tracer: impl ParseTracer,
                    cache: &mut ParseCache<'a>,
                ) -> ParseResult<'a, Parsed> {
                    let ParseOk { state, .. } = parse_Whitespace(state, tracer, cache)?;
                    let ok_result = parse_character_literal(state, 'a')?;
                    Ok(ok_result.map(|_| Parsed))
                }
                pub struct Parsed;
            }
            mod part_1 {
                use super::*;
                #[inline(always)]
                pub fn parse<'a>(
                    state: ParseState<'a>,
                    tracer: impl ParseTracer,
                    cache: &mut ParseCache<'a>,
                ) -> ParseResult<'a, Parsed> {
                    let ParseOk { state, .. } = parse_Whitespace(state, tracer, cache)?;
                    let ok_result = parse_Recursive(state, tracer, cache)?;
                    Ok(ok_result.map(|result| Parsed {
                        inner: Some(Box::new(result)),
                    }))
                }
                pub struct Parsed {
                    pub inner: Option<Box<Recursive>>,
                }
            }
            mod part_2 {
                use super::*;
                #[inline(always)]
                pub fn parse<'a>(
                    state: ParseState<'a>,
                    tracer: impl ParseTracer,
                    cache: &mut ParseCache<'a>,
                ) -> ParseResult<'a, Parsed> {
                    let ParseOk { state, .. } = parse_Whitespace(state, tracer, cache)?;
                    let ok_result = parse_character_literal(state, 'b')?;
                    Ok(ok_result.map(|_| Parsed))
                }
                pub struct Parsed;
            }
            #[inline(always)]
            pub fn parse<'a>(
                state: ParseState<'a>,
                tracer: impl ParseTracer,
                cache: &mut ParseCache<'a>,
            ) -> ParseResult<'a, Parsed> {
                let mut state = state;
                let mut farthest_error: Option<ParseError> = None;
                match part_0::parse(state, tracer, cache) {
                    Ok(ParseOk {
                        result: _,
                        state: new_state,
                        farthest_error: new_farthest_error,
                    }) => {
                        farthest_error = combine_errors(farthest_error, new_farthest_error);
                        state = new_state;
                    }
                    Err(err) => return Err(combine_errors(farthest_error, Some(err)).unwrap()),
                }
                let result = match part_1::parse(state, tracer, cache) {
                    Ok(ParseOk {
                        result,
                        state: new_state,
                        farthest_error: new_farthest_error,
                    }) => {
                        farthest_error = combine_errors(farthest_error, new_farthest_error);
                        state = new_state;
                        result
                    }
                    Err(err) => return Err(combine_errors(farthest_error, Some(err)).unwrap()),
                };
                let inner = result.inner;
                match part_2::parse(state, tracer, cache) {
                    Ok(ParseOk {
                        result: _,
                        state: new_state,
                        farthest_error: new_farthest_error,
                    }) => {
                        farthest_error = combine_errors(farthest_error, new_farthest_error);
                        state = new_state;
                    }
                    Err(err) => return Err(combine_errors(farthest_error, Some(err)).unwrap()),
                }
                Ok(ParseOk {
                    result: Parsed { inner },
                    state,
                    farthest_error,
                })
            }
            pub struct Parsed {
                pub inner: Option<Box<Recursive>>,
            }
        }
        mod choice_1 {
            use super::*;
            mod part_0 {
                use super::*;
                #[inline(always)]
                pub fn parse<'a>(
                    state: ParseState<'a>,
                    tracer: impl ParseTracer,
                    cache: &mut ParseCache<'a>,
                ) -> ParseResult<'a, Parsed> {
                    let ParseOk { state, .. } = parse_Whitespace(state, tracer, cache)?;
                    let ok_result = parse_character_literal(state, 'a')?;
                    Ok(ok_result.map(|_| Parsed))
                }
                pub struct Parsed;
            }
            mod part_1 {
                use super::*;
                #[inline(always)]
                pub fn parse<'a>(
                    state: ParseState<'a>,
                    tracer: impl ParseTracer,
                    cache: &mut ParseCache<'a>,
                ) -> ParseResult<'a, Parsed> {
                    let ParseOk { state, .. } = parse_Whitespace(state, tracer, cache)?;
                    let ok_result = parse_Recursive(state, tracer, cache)?;
                    Ok(ok_result.map(|result| Parsed {
                        inner: Some(Box::new(result)),
                    }))
                }
                pub struct Parsed {
                    pub inner: Option<Box<Recursive>>,
                }
            }
            mod part_2 {
                use super::*;
                #[inline(always)]
                pub fn parse<'a>(
                    state: ParseState<'a>,
                    tracer: impl ParseTracer,
                    cache: &mut ParseCache<'a>,
                ) -> ParseResult<'a, Parsed> {
                    let ParseOk { state, .. } = parse_Whitespace(state, tracer, cache)?;
                    let ok_result = parse_character_literal(state, 'c')?;
                    Ok(ok_result.map(|_| Parsed))
                }
                pub struct Parsed;
            }
            #[inline(always)]
            pub fn parse<'a>(
                state: ParseState<'a>,
                tracer: impl ParseTracer,
                cache: &mut ParseCache<'a>,
            ) -> ParseResult<'a, Parsed> {
                let mut state = state;
                let mut farthest_error: Option<ParseError> = None;
                match part_0::parse(state, tracer, cache) {
                    Ok(ParseOk {
                        result: _,
                        state: new_state,
                        farthest_error: new_farthest_error,
                    }) => {
                        farthest_error = combine_errors(farthest_error, new_farthest_error);
                        state = new_state;
                    }
                    Err(err) => return Err(combine_errors(farthest_error, Some(err)).unwrap()),
                }
                let result = match part_1::parse(state, tracer, cache) {
                    Ok(ParseOk {
                        result,
                        state: new_state,
                        farthest_error: new_farthest_error,
                    }) => {
                        farthest_error = combine_errors(farthest_error, new_farthest_error);
                        state = new_state;
                        result
                    }
                    Err(err) => return Err(combine_errors(farthest_error, Some(err)).unwrap()),
                };
                let inner = result.inner;
                match part_2::parse(state, tracer, cache) {
                    Ok(ParseOk {
                        result: _,
                        state: new_state,
                        farthest_error: new_farthest_error,
                    }) => {
                        farthest_error = combine_errors(farthest_error, new_farthest_error);
                        state = new_state;
                    }
                    Err(err) => return Err(combine_errors(farthest_error, Some(err)).unwrap()),
                }
                Ok(ParseOk {
                    result: Parsed { inner },
                    state,
                    farthest_error,
                })
            }
            pub struct Parsed {
                pub inner: Option<Box<Recursive>>,
            }
        }
        mod choice_2 {
            use super::*;
            #[inline(always)]
            pub fn parse<'a>(
                state: ParseState<'a>,
                tracer: impl ParseTracer,
                cache: &mut ParseCache<'a>,
            ) -> ParseResult<'a, Parsed> {
                Ok(ParseOk {
                    result: Parsed,
                    state,
                    farthest_error: None,
                })
            }
            pub struct Parsed;
        }
        #[inline(always)]
        pub fn parse<'a>(
            state: ParseState<'a>,
            tracer: impl ParseTracer,
            cache: &mut ParseCache<'a>,
        ) -> ParseResult<'a, Parsed> {
            let mut state = state;
            let mut farthest_error: Option<ParseError> = None;
            match choice_0::parse(state.clone(), tracer, cache) {
                Ok(ok_result) => {
                    return Ok(ok_result.map(|result| Parsed {
                        inner: result.inner,
                    }))
                }
                Err(err) => farthest_error = combine_errors(farthest_error, Some(err)),
            }
            match choice_1::parse(state.clone(), tracer, cache) {
                Ok(ok_result) => {
                    return Ok(ok_result.map(|result| Parsed {
                        inner: result.inner,
                    }))
                }
                Err(err) => farthest_error = combine_errors(farthest_error, Some(err)),
            }
            match choice_2::parse(state.clone(), tracer, cache) {
                Ok(ok_result) => return Ok(ok_result.map(|result| Parsed { inner: None })),
                Err(err) => farthest_error = combine_errors(farthest_error, Some(err)),
            }
            Err(farthest_error.unwrap_or_else(|| state.report_error(ParseErrorSpecifics::Other)))
        }
        pub struct Parsed {
            pub inner: Option<Box<Recursive>>,
        }
        #[inline(always)]
        pub fn rule_parser<'a>(
            state: ParseState<'a>,
            tracer: impl ParseTracer,
            cache: &mut ParseCache<'a>,
        ) -> ParseResult<'a, super::Recursive> {
            let result = parse(state, tracer, cache)?.map(|r| super::Recursive { inner: r.inner });
            Ok(result)
        }
    }
    #[inline]
    pub(super) fn parse_Recursive<'a>(
        state: ParseState<'a>,
        tracer: impl ParseTracer,
        cache: &mut ParseCache<'a>,
    ) -> ParseResult<'a, Recursive> {
        tracer.run_traced("Recursive", state, |state, tracer| {
            let cache_key = state.cache_key();
            if let Some(cached) = cache.c_Recursive.get(&cache_key) {
                cached.clone()
            } else {
                let mut best_result = Err(state.clone().report_error(ParseErrorSpecifics::Other));
                cache.c_Recursive.insert(cache_key, best_result.clone());
                loop {
                    let new_result = Recursive_impl::rule_parser(state.clone(), tracer, cache);
                    match (new_result, &best_result) {
                        (Ok(nro), Ok(bro)) => {
                            if nro.state.is_further_than(&bro.state) {
                                best_result = Ok(nro);
                                cache.c_Recursive.insert(cache_key, best_result.clone());
                            } else {
                                break;
                            }
                        }
                        (Ok(nro), Err(bre)) => {
                            best_result = Ok(nro);
                            cache.c_Recursive.insert(cache_key, best_result.clone());
                        }
                        (Err(nre), Ok(bro)) => {
                            break;
                        }
                        (Err(nre), Err(bre)) => {
                            best_result = Err(nre);
                            cache.c_Recursive.insert(cache_key, best_result.clone());
                        }
                    }
                }
                best_result
            }
        })
    }
}
use ntest::timeout;
use peginator::PegParser;

#[test]
#[timeout(1000)]
fn test_memoization() {
    let s = Root::parse(&format!("{:a>100}{:c>100}.", "", ""))
        .unwrap()
        .parsed;
    let expected: Option<Box<Recursive>> =
        (0..101).fold(None, |r, _| Some(Box::new(Recursive { inner: r })));
    assert_eq!(s, *expected.unwrap());
}
